#!/bin/bash
#
# Git-Go - Intelligent Git Repository Manager
# https://github.com/USERNAME/git-go
#
# Create and manage git repositories with smart sync scripts,
# VS Code integration, and AI-assisted development support.
#

set -e

# Script directory and paths
# Check if we're running from a symlink
SCRIPT_PATH="${BASH_SOURCE[0]}"
if [[ -L "$SCRIPT_PATH" ]]; then
    # Follow the symlink to get the real script location
    SCRIPT_PATH="$(readlink -f "$SCRIPT_PATH")"
fi
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")/.." && pwd)"
LIB_DIR="$SCRIPT_DIR/lib"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/git-go"
CONFIG_FILE="$CONFIG_DIR/config"

# Version
VERSION="1.0.9"

# Library loading flags
COLORS_LOADED=false
GIT_UTILS_LOADED=false

# Lazy load color library
load_colors() {
    if [[ "$COLORS_LOADED" != "true" ]]; then
        source "$LIB_DIR/colors.sh"
        COLORS_LOADED=true
    fi
}

# Lazy load git utils
load_git_utils() {
    if [[ "$GIT_UTILS_LOADED" != "true" ]]; then
        source "$LIB_DIR/git-utils.sh"
        GIT_UTILS_LOADED=true
    fi
}

# Configuration cache
CONFIG_LOADED=false

# Load configuration
load_config() {
    # Skip if already loaded
    if [[ "$CONFIG_LOADED" == "true" ]]; then
        return
    fi
    
    # Default configuration
    GIT_PRIMARY_HOST="github.com"
    GIT_PRIMARY_USER="${USER}"
    GIT_PRIMARY_PREFIX="git@github.com:"
    GIT_SECONDARY_HOST=""
    GIT_SECONDARY_USER=""
    GIT_SECONDARY_PREFIX=""
    DEFAULT_BRANCH="main"
    ENABLE_VSCODE_INTEGRATION=true
    ENABLE_CLAUDE_MD=true
    DEFAULT_GITIGNORE_TEMPLATES="node,python"
    USE_COLORS=true
    
    # Load user config if exists
    if [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"
    fi
    
    # Set working directory
    WORK_DIR="${WORK_DIR:-$HOME/src}"
    
    # Mark as loaded
    CONFIG_LOADED=true
}

# Show usage
usage() {
    load_colors
    echo -e "${BOLD}Git-Go v${VERSION}${NC} - Intelligent Git Repository Manager

${BOLD}USAGE:${NC}
    git-go [OPTIONS] [COMMAND]

${BOLD}COMMANDS:${NC}
    new              Create a new repository
    fork             Fork an existing repository
    config           Edit configuration
    status           Show repository sync status
    setup            Run setup wizard
    version          Show version information
    help             Show this help message

${BOLD}OPTIONS:${NC}
    -n, --name       Repository name (for new/fork)
    -u, --url        Repository URL (for fork)
    -d, --dir        Working directory (default: ~/src)
    --dry-run        Validate inputs without creating anything
    -h, --help       Show help message

${BOLD}EXAMPLES:${NC}
    git-go new --name my-project
    git-go fork --url https://github.com/user/repo
    git-go config"
}

# Parse command line arguments
parse_args() {
    COMMAND=""
    REPO_NAME=""
    REPO_URL=""
    DRY_RUN=false
    
    # Load colors for error messages
    load_colors
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            new|fork|config|status|setup|version|help)
                COMMAND=$1
                shift
                ;;
            -n|--name)
                REPO_NAME="$2"
                shift 2
                ;;
            -u|--url)
                REPO_URL="$2"
                shift 2
                ;;
            -d|--dir)
                WORK_DIR="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
    
    # Don't default to anything - let main() handle it
}

# Create VS Code integration
create_vscode_integration() {
    local repo_dir=$1
    
    if [[ "$ENABLE_VSCODE_INTEGRATION" != "true" ]]; then
        return
    fi
    
    mkdir -p "$repo_dir/.vscode"
    
    cat > "$repo_dir/.vscode/tasks.json" << 'EOF'
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Git Sync",
            "type": "shell",
            "command": "${workspaceFolder}/scripts/sync.sh",
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "presentation": {
                "reveal": "always",
                "panel": "terminal"
            },
            "problemMatcher": []
        }
    ]
}
EOF
}

# Get application subtype based on type
get_app_subtype() {
    local app_type="$1"
    local subtype=""
    
    case "$app_type" in
        "Web Applications")
            echo -e "\n${BOLD}Select Web Application Subtype:${NC}" >&2
            echo "  1) Static Sites (marketing pages, portfolios, documentation)" >&2
            echo "  2) Single Page Apps/SPAs (Gmail, Twitter, Spotify Web)" >&2
            echo "  3) Progressive Web Apps/PWAs (installable web apps with offline support)" >&2
            echo "  4) Server-Side Rendered/SSR (e-commerce, blogs, news sites)" >&2
            echo "  5) Jamstack Sites (static + APIs, Gatsby, Astro sites)" >&2
            echo "  6) Web-Based SaaS (Stripe Dashboard, Notion, Linear)" >&2
            echo "  7) Enterprise Web Apps (CRMs, ERPs, internal tools)" >&2
            echo "  8) E-commerce Platforms (Shopify stores, marketplaces)" >&2
            echo "  9) Social Networks (forums, communities, dating apps)" >&2
            echo " 10) Content Management Systems (WordPress, Ghost, Strapi)" >&2
            echo " 11) Learning Management Systems (course platforms, online schools)" >&2
            echo " 12) Real-time Collaboration (Google Docs, Figma, Miro)" >&2
            echo " 13) Dashboards/Analytics (admin panels, BI tools)" >&2
            echo " 14) Streaming Platforms (YouTube, Netflix web versions)" >&2
            read -p "Choice (1-14): " choice >&2
            case "$choice" in
                1) subtype="Static Sites" ;;
                2) subtype="Single Page Apps/SPAs" ;;
                3) subtype="Progressive Web Apps/PWAs" ;;
                4) subtype="Server-Side Rendered/SSR" ;;
                5) subtype="Jamstack Sites" ;;
                6) subtype="Web-Based SaaS" ;;
                7) subtype="Enterprise Web Apps" ;;
                8) subtype="E-commerce Platforms" ;;
                9) subtype="Social Networks" ;;
                10) subtype="Content Management Systems" ;;
                11) subtype="Learning Management Systems" ;;
                12) subtype="Real-time Collaboration" ;;
                13) subtype="Dashboards/Analytics" ;;
                14) subtype="Streaming Platforms" ;;
                *) subtype="Web Application" ;;
            esac
            ;;
        "Mobile Applications")
            echo -e "\n${BOLD}Select Mobile Application Subtype:${NC}" >&2
            echo "  1) Native iOS (Swift/SwiftUI apps)" >&2
            echo "  2) Native Android (Kotlin/Java apps)" >&2
            echo "  3) Cross-Platform Mobile (React Native, Flutter, Ionic)" >&2
            echo "  4) Hybrid Apps (Capacitor, Cordova - web wrapped as mobile)" >&2
            echo "  5) Mobile Games (Unity, native game engines)" >&2
            read -p "Choice (1-5): " choice >&2
            case "$choice" in
                1) subtype="Native iOS" ;;
                2) subtype="Native Android" ;;
                3) subtype="Cross-Platform Mobile" ;;
                4) subtype="Hybrid Apps" ;;
                5) subtype="Mobile Games" ;;
                *) subtype="Mobile Application" ;;
            esac
            ;;
        "Desktop Applications")
            echo -e "\n${BOLD}Select Desktop Application Subtype:${NC}" >&2
            echo "  1) Electron Apps (VS Code, Discord, Slack)" >&2
            echo "  2) Native Windows (WPF, WinForms, UWP apps)" >&2
            echo "  3) Native macOS (Swift/AppKit apps)" >&2
            echo "  4) Native Linux (GTK, Qt applications)" >&2
            echo "  5) Cross-Platform Native (Tauri, Qt, JavaFX)" >&2
            read -p "Choice (1-5): " choice >&2
            case "$choice" in
                1) subtype="Electron Apps" ;;
                2) subtype="Native Windows" ;;
                3) subtype="Native macOS" ;;
                4) subtype="Native Linux" ;;
                5) subtype="Cross-Platform Native" ;;
                *) subtype="Desktop Application" ;;
            esac
            ;;
        "Command Line Applications")
            echo -e "\n${BOLD}Select Command Line Application Subtype:${NC}" >&2
            echo "  1) CLI Tools (Git, npm, development tools)" >&2
            echo "  2) Terminal UIs/TUIs (htop, vim, terminal dashboards)" >&2
            echo "  3) Build Tools (Webpack, Vite, bundlers)" >&2
            echo "  4) Automation Scripts (Python/Bash/Node scripts)" >&2
            read -p "Choice (1-4): " choice >&2
            case "$choice" in
                1) subtype="CLI Tools" ;;
                2) subtype="Terminal UIs/TUIs" ;;
                3) subtype="Build Tools" ;;
                4) subtype="Automation Scripts" ;;
                *) subtype="Command Line Tool" ;;
            esac
            ;;
        "API/Backend Services")
            echo -e "\n${BOLD}Select API/Backend Service Subtype:${NC}" >&2
            echo "  1) REST APIs (traditional HTTP services)" >&2
            echo "  2) GraphQL APIs (flexible query services)" >&2
            echo "  3) Microservices (distributed service architectures)" >&2
            echo "  4) Serverless Functions (Lambda, Vercel Functions)" >&2
            echo "  5) WebSocket Services (real-time communication)" >&2
            echo "  6) gRPC Services (high-performance RPC)" >&2
            read -p "Choice (1-6): " choice >&2
            case "$choice" in
                1) subtype="REST APIs" ;;
                2) subtype="GraphQL APIs" ;;
                3) subtype="Microservices" ;;
                4) subtype="Serverless Functions" ;;
                5) subtype="WebSocket Services" ;;
                6) subtype="gRPC Services" ;;
                *) subtype="API/Backend Service" ;;
            esac
            ;;
        "Game Development")
            echo -e "\n${BOLD}Select Game Development Subtype:${NC}" >&2
            echo "  1) Browser Games (JavaScript/WebGL games)" >&2
            echo "  2) Mobile Games (iOS/Android native or Unity)" >&2
            echo "  3) PC Games (Steam, Epic Games)" >&2
            echo "  4) Console Games (PlayStation, Xbox, Nintendo)" >&2
            read -p "Choice (1-4): " choice >&2
            case "$choice" in
                1) subtype="Browser Games" ;;
                2) subtype="Mobile Games" ;;
                3) subtype="PC Games" ;;
                4) subtype="Console Games" ;;
                *) subtype="Game" ;;
            esac
            ;;
        "Embedded/IoT Applications")
            echo -e "\n${BOLD}Select Embedded/IoT Application Subtype:${NC}" >&2
            echo "  1) Firmware (microcontroller programming)" >&2
            echo "  2) IoT Devices (smart home, industrial sensors)" >&2
            echo "  3) Automotive (car infotainment systems)" >&2
            echo "  4) Wearables (smartwatch apps)" >&2
            read -p "Choice (1-4): " choice >&2
            case "$choice" in
                1) subtype="Firmware" ;;
                2) subtype="IoT Devices" ;;
                3) subtype="Automotive" ;;
                4) subtype="Wearables" ;;
                *) subtype="Embedded/IoT Application" ;;
            esac
            ;;
        "Browser Extensions")
            echo -e "\n${BOLD}Select Browser Extension Subtype:${NC}" >&2
            echo "  1) Chrome Extensions (ad blockers, productivity tools)" >&2
            echo "  2) Firefox Add-ons (privacy tools, themes)" >&2
            echo "  3) Safari Extensions (password managers)" >&2
            read -p "Choice (1-3): " choice >&2
            case "$choice" in
                1) subtype="Chrome Extensions" ;;
                2) subtype="Firefox Add-ons" ;;
                3) subtype="Safari Extensions" ;;
                *) subtype="Browser Extension" ;;
            esac
            ;;
        "AI/ML Applications")
            echo -e "\n${BOLD}Select AI/ML Application Subtype:${NC}" >&2
            echo "  1) Chatbots (customer service, virtual assistants)" >&2
            echo "  2) Computer Vision (image recognition, filters)" >&2
            echo "  3) NLP Tools (translation, sentiment analysis)" >&2
            echo "  4) Recommendation Systems (Netflix, Amazon suggestions)" >&2
            read -p "Choice (1-4): " choice >&2
            case "$choice" in
                1) subtype="Chatbots" ;;
                2) subtype="Computer Vision" ;;
                3) subtype="NLP Tools" ;;
                4) subtype="Recommendation Systems" ;;
                *) subtype="AI/ML Application" ;;
            esac
            ;;
        "Specialized Applications")
            echo -e "\n${BOLD}Select Specialized Application Subtype:${NC}" >&2
            echo "  1) AR/VR Apps (Meta Quest, Apple Vision Pro)" >&2
            echo "  2) Blockchain/Web3 (DApps, smart contracts)" >&2
            echo "  3) Data Visualization (Tableau, D3.js apps)" >&2
            echo "  4) Scientific Computing (MATLAB, Jupyter notebooks)" >&2
            echo "  5) CAD/3D Software (AutoCAD, Blender plugins)" >&2
            read -p "Choice (1-5): " choice >&2
            case "$choice" in
                1) subtype="AR/VR Apps" ;;
                2) subtype="Blockchain/Web3" ;;
                3) subtype="Data Visualization" ;;
                4) subtype="Scientific Computing" ;;
                5) subtype="CAD/3D Software" ;;
                *) subtype="Specialized Application" ;;
            esac
            ;;
        *)
            subtype="Application"
            ;;
    esac
    
    echo "$subtype"
}

# Copy template files based on application type
copy_template_files() {
    local repo_dir=$1
    local repo_name=$2
    local app_type=$3
    local app_subtype=$4
    
    # Create README.md with application type information
    cat > "$repo_dir/README.md" << EOF
# $repo_name

**Application Type:** $app_type  
**Subtype:** $app_subtype

## Description

Add your project description here.

## Getting Started

### Prerequisites

- List any prerequisites here

### Installation

\`\`\`bash
# Add installation steps
\`\`\`

### Usage

\`\`\`bash
# Add usage examples
\`\`\`

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details.
EOF
}

# Create claude.md file
create_claude_md() {
    local repo_dir=$1
    local repo_name=$2
    local app_type=$3
    local app_subtype=$4
    
    if [[ "$ENABLE_CLAUDE_MD" != "true" ]]; then
        return
    fi
    
    cat > "$repo_dir/CLAUDE.md" << EOF
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project: $repo_name

**Application Type:** $app_type  
**Subtype:** $app_subtype

### Quick Start
- Build: \`npm run build\` (update as needed)
- Test: \`npm test\` (update as needed)
- Lint: \`npm run lint\` (update as needed)

### Architecture Notes
<!-- Describe key architectural decisions and patterns -->

### Development Workflow
1. Make changes
2. Run tests
3. Use \`./scripts/sync.sh\` or Ctrl+Shift+B in VS Code to sync

### AI Assistant Guidelines
- Read relevant files before making changes
- Follow existing code patterns
- Consider impact on other components
- Suggest tests for new features
EOF
}

# Create sync script
create_sync_script() {
    local repo_dir=$1
    local repo_name=$2
    local is_fork=$3
    
    mkdir -p "$repo_dir/scripts"
    
    cat > "$repo_dir/scripts/sync.sh" << 'EOF'
#!/bin/bash
# Git sync script - generated by git-go

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Show repository status
echo -e "${BLUE}=== Git Sync ===${NC}"
echo -e "Repository: $(basename $(git rev-parse --show-toplevel))"
echo -e "Branch: $(git branch --show-current)"
echo -e "Status: $(git status --porcelain | wc -l) uncommitted changes"

# Check for uncommitted changes
if ! git diff-index --quiet HEAD -- 2>/dev/null; then
    echo -e "\n${YELLOW}You have uncommitted changes.${NC}"
    read -p "Stash them? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        git stash push -m "Auto-stash $(date +%Y%m%d-%H%M%S)"
        STASHED=true
    else
        echo -e "${RED}Cannot sync with uncommitted changes${NC}"
        exit 1
    fi
fi

# Get current branch
BRANCH=$(git branch --show-current)

EOF
    
    if [[ "$is_fork" == "true" ]]; then
        cat >> "$repo_dir/scripts/sync.sh" << 'EOF'
# Sync with upstream (for forks)
if git remote | grep -q upstream; then
    echo -e "\n${YELLOW}Fetching upstream...${NC}"
    git fetch upstream
    
    if git rev-list --count HEAD..upstream/$BRANCH &>/dev/null; then
        BEHIND=$(git rev-list --count HEAD..upstream/$BRANCH)
        if [[ $BEHIND -gt 0 ]]; then
            echo -e "${YELLOW}$BEHIND commits behind upstream${NC}"
            read -p "Merge upstream changes? (y/n) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                git merge upstream/$BRANCH -m "Merge upstream"
            fi
        fi
    fi
fi

EOF
    fi
    
    cat >> "$repo_dir/scripts/sync.sh" << 'EOF'
# Push to all remotes
for remote in $(git remote); do
    echo -e "\n${YELLOW}Pushing to $remote...${NC}"
    if git push $remote $BRANCH; then
        echo -e "${GREEN}✓ Pushed to $remote${NC}"
    else
        echo -e "${RED}✗ Failed to push to $remote${NC}"
    fi
done

# Restore stash if needed
if [[ "${STASHED:-false}" == "true" ]]; then
    echo
    read -p "Restore stashed changes? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        git stash pop
    fi
fi

echo -e "\n${GREEN}✅ Sync complete!${NC}"
EOF
    
    chmod +x "$repo_dir/scripts/sync.sh"
}

# Launch editor if available
launch_editor() {
    local repo_dir="$1"
    
    if command_exists cursor; then
        echo
        info "Launching Cursor..."
        cursor "$repo_dir" &
    elif command_exists code; then
        echo
        info "Launching VS Code..."
        code "$repo_dir" &
    fi
}

# Setup git remotes and push initial commit
setup_and_push_remotes() {
    local repo_name="$1"
    
    step "Setting up remotes"
    
    if [[ -n "$GIT_PRIMARY_PREFIX" ]]; then
        local primary_url="${GIT_PRIMARY_PREFIX}${GIT_PRIMARY_USER}/${repo_name}.git"
        setup_remote "origin" "$primary_url"
        info "Primary remote: $primary_url"
    fi
    
    if [[ -n "$GIT_SECONDARY_PREFIX" ]]; then
        local secondary_url="${GIT_SECONDARY_PREFIX}${GIT_SECONDARY_USER}/${repo_name}.git"
        setup_remote "secondary" "$secondary_url"
        info "Secondary remote: $secondary_url"
    fi
    
    # Try to push
    if [[ -n "$GIT_PRIMARY_PREFIX" ]]; then
        step "Pushing to remotes"
        if git push -u origin "$DEFAULT_BRANCH" 2>&1; then
            success "Pushed to origin"
        else
            warning "Push to origin failed (this is normal if auto-create is disabled on your git server)"
        fi
    fi
}

# Create MIT LICENSE file
create_mit_license() {
    local repo_dir="$1"
    
    cat > "$repo_dir/LICENSE" << EOF
MIT License

Copyright (c) $(date +%Y) $GIT_PRIMARY_USER

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
EOF
}

# Create .gitignore file with common and template-specific patterns
create_gitignore() {
    local repo_dir="$1"
    
    cd "$repo_dir"
    touch .gitignore
    
    # Add common patterns
    cat >> .gitignore << 'EOF'
# OS
.DS_Store
Thumbs.db

# Editor
.vscode/*
!.vscode/tasks.json
.idea/
*.swp
*.swo

# Logs
*.log
logs/

# Environment
.env
.env.*
!.env.example
EOF
    
    # Add template-specific patterns
    if [[ -n "$DEFAULT_GITIGNORE_TEMPLATES" ]]; then
        IFS=',' read -ra TEMPLATES <<< "$DEFAULT_GITIGNORE_TEMPLATES"
        for template in "${TEMPLATES[@]}"; do
            case "$template" in
                node)
                    echo -e "\n# Node\nnode_modules/\ndist/\n.npm/" >> .gitignore
                    ;;
                python)
                    echo -e "\n# Python\n__pycache__/\n*.pyc\nvenv/\n.pytest_cache/" >> .gitignore
                    ;;
                go)
                    echo -e "\n# Go\n*.exe\n*.test\n*.out\nvendor/" >> .gitignore
                    ;;
            esac
        done
    fi
}

# Select application type interactively
select_application_type() {
    echo
    echo -e "${BOLD}Select Application Type:${NC}"
    echo "  1) Web Applications"
    echo "  2) Mobile Applications"
    echo "  3) Desktop Applications"
    echo "  4) Command Line Applications"
    echo "  5) API/Backend Services"
    echo "  6) Game Development"
    echo "  7) Embedded/IoT Applications"
    echo "  8) Browser Extensions"
    echo "  9) AI/ML Applications"
    echo " 10) Specialized Applications"
    read -p "Choice (1-10): " app_choice
    
    case "$app_choice" in
        1) SELECTED_APP_TYPE="Web Applications" ;;
        2) SELECTED_APP_TYPE="Mobile Applications" ;;
        3) SELECTED_APP_TYPE="Desktop Applications" ;;
        4) SELECTED_APP_TYPE="Command Line Applications" ;;
        5) SELECTED_APP_TYPE="API/Backend Services" ;;
        6) SELECTED_APP_TYPE="Game Development" ;;
        7) SELECTED_APP_TYPE="Embedded/IoT Applications" ;;
        8) SELECTED_APP_TYPE="Browser Extensions" ;;
        9) SELECTED_APP_TYPE="AI/ML Applications" ;;
        10) SELECTED_APP_TYPE="Specialized Applications" ;;
        *) SELECTED_APP_TYPE="General Application" ;;
    esac
    
    # Get subtype based on type
    SELECTED_APP_SUBTYPE=$(get_app_subtype "$SELECTED_APP_TYPE")
}

# Create a new repository
cmd_new() {
    load_colors
    load_git_utils
    
    local repo_name="$REPO_NAME"
    local app_type=""
    local app_subtype=""
    
    # Interactive mode if name not provided
    if [[ -z "$repo_name" ]]; then
        # In dry-run mode, we need a name
        if [[ "$DRY_RUN" == "true" ]]; then
            error "New command requires --name parameter"
            exit 1
        fi
        echo -e "${BOLD}Create New Repository${NC}\n"
        read -p "Repository name: " repo_name
    fi
    
    # Validate name
    if ! validate_repo_name "$repo_name"; then
        error "Invalid repository name. Use only letters, numbers, dots, hyphens, and underscores."
        exit 1
    fi
    
    # Ask for application type (only in interactive mode)
    if [[ "$DRY_RUN" != "true" ]]; then
        select_application_type
        app_type="$SELECTED_APP_TYPE"
        app_subtype="$SELECTED_APP_SUBTYPE"
    fi
    
    # If dry-run, just validate and exit
    if [[ "$DRY_RUN" == "true" ]]; then
        success "Validation passed for repository name: $repo_name"
        exit 0
    fi
    
    local repo_dir="$WORK_DIR/$repo_name"
    
    # Check if already exists
    if [[ -d "$repo_dir" ]]; then
        error "Directory $repo_dir already exists!"
        exit 1
    fi
    
    # Create repository
    step "Creating repository at $repo_dir"
    mkdir -p "$repo_dir"
    cd "$repo_dir"
    
    git init -b "$DEFAULT_BRANCH"
    
    # Create initial files
    step "Creating initial files"
    
    # Use copy_template_files to create README.md with app type info
    copy_template_files "$repo_dir" "$repo_name" "$app_type" "$app_subtype"
    
    # Create .gitignore
    create_gitignore "$repo_dir"
    
    # Create LICENSE
    create_mit_license "$repo_dir"
    
    # Create VS Code integration
    create_vscode_integration "$repo_dir"
    
    # Create claude.md
    create_claude_md "$repo_dir" "$repo_name" "$app_type" "$app_subtype"
    
    # Create sync script
    create_sync_script "$repo_dir" "$repo_name" "false"
    
    # Initial commit
    git add .
    git commit -m "Initial commit"
    
    # Setup remotes and push
    setup_and_push_remotes "$repo_name"
    
    success "Repository created successfully!"
    echo
    highlight "Next steps:"
    echo "  cd $repo_dir"
    echo "  # Start coding!"
    echo "  ./scripts/sync.sh  # or Ctrl+Shift+B in VS Code"
    
    # Launch editor if available
    launch_editor "$repo_dir"
}

# Fork a repository
cmd_fork() {
    load_colors
    load_git_utils
    
    local repo_url="$REPO_URL"
    
    # Interactive mode if URL not provided
    if [[ -z "$repo_url" ]]; then
        # In dry-run mode, we need a URL
        if [[ "$DRY_RUN" == "true" ]]; then
            error "Fork command requires --url parameter"
            exit 1
        fi
        echo -e "${BOLD}Fork Repository${NC}\n"
        read -p "Repository URL: " repo_url
    fi
    
    # Extract repo info
    local repo_info=$(extract_repo_info "$repo_url")
    local author=$(echo "$repo_info" | cut -d'|' -f1)
    local repo=$(echo "$repo_info" | cut -d'|' -f2)
    
    if [[ -z "$author" ]] || [[ -z "$repo" ]]; then
        error "Could not parse repository URL"
        exit 1
    fi
    
    # If dry-run, just validate and exit
    if [[ "$DRY_RUN" == "true" ]]; then
        success "Validation passed for fork URL: $repo_url"
        exit 0
    fi
    
    # Use provided name or ask for it
    local repo_name="$REPO_NAME"
    if [[ -z "$repo_name" ]] && [[ "$DRY_RUN" != "true" ]]; then
        echo
        read -p "Repository name (press Enter to use '$repo'): " custom_name
        repo_name="${custom_name:-$repo}"
    elif [[ -z "$repo_name" ]]; then
        # For dry-run, use the original repo name
        repo_name="$repo"
    fi
    
    local repo_dir="$WORK_DIR/$repo_name"
    
    # Check if already exists
    if [[ -d "$repo_dir" ]]; then
        error "Directory $repo_dir already exists!"
        exit 1
    fi
    
    # Clone repository
    step "Cloning $repo_url"
    git clone "$repo_url" "$repo_dir"
    cd "$repo_dir"
    
    # Get default branch
    local default_branch=$(get_default_branch origin)
    
    # Setup remotes
    step "Setting up remotes"
    git remote rename origin upstream
    
    if [[ -n "$GIT_PRIMARY_PREFIX" ]]; then
        local primary_url="${GIT_PRIMARY_PREFIX}${GIT_PRIMARY_USER}/${repo_name}.git"
        setup_remote "origin" "$primary_url"
        info "Primary remote: $primary_url"
    fi
    
    if [[ -n "$GIT_SECONDARY_PREFIX" ]]; then
        local secondary_url="${GIT_SECONDARY_PREFIX}${GIT_SECONDARY_USER}/${repo_name}.git"
        setup_remote "secondary" "$secondary_url"
        info "Secondary remote: $secondary_url"
    fi
    
    # Create VS Code integration
    create_vscode_integration "$repo_dir"
    
    # Create claude.md (for fork)
    create_claude_md "$repo_dir" "$repo_name" "" ""
    
    # Create sync script
    create_sync_script "$repo_dir" "$repo_name" "true"
    
    # Try to push
    if [[ -n "$GIT_PRIMARY_PREFIX" ]]; then
        step "Pushing to your remotes"
        if git push -u origin "$default_branch" 2>/dev/null; then
            success "Pushed to origin"
        else
            warning "Could not push to origin. Create the repository first."
        fi
    fi
    
    success "Fork created successfully!"
    echo
    highlight "Next steps:"
    echo "  cd $repo_dir"
    echo "  # Make your changes"
    echo "  ./scripts/sync.sh  # Sync with upstream and your remotes"
    
    # Launch editor if available
    launch_editor "$repo_dir"
}

# Edit configuration
cmd_config() {
    load_colors
    # Create config directory if needed
    mkdir -p "$CONFIG_DIR"
    
    # Copy example if no config exists
    if [[ ! -f "$CONFIG_FILE" ]]; then
        cp "$SCRIPT_DIR/config/git-go.conf.example" "$CONFIG_FILE"
        info "Created configuration file at $CONFIG_FILE"
    fi
    
    # Open in editor
    if [[ -n "$EDITOR" ]]; then
        $EDITOR "$CONFIG_FILE"
    elif command_exists code; then
        code "$CONFIG_FILE"
    elif command_exists nano; then
        nano "$CONFIG_FILE"
    else
        vi "$CONFIG_FILE"
    fi
}

# Show repository status across remotes
cmd_status() {
    load_colors
    load_git_utils
    
    # Check if we're in a git repository
    if ! is_git_repo; then
        error "Not in a git repository"
        exit 1
    fi
    
    echo -e "${BOLD}Git-Go Repository Status${NC}\n"
    
    # Current branch
    local current_branch=$(get_current_branch)
    echo -e "${CYAN}Current Branch:${NC} $current_branch"
    echo
    
    # Check each remote
    local remotes=$(git remote)
    if [[ -z "$remotes" ]]; then
        warning "No remotes configured"
        return
    fi
    
    for remote in $remotes; do
        echo -e "${BOLD}Remote: $remote${NC}"
        local url=$(git remote get-url "$remote" 2>/dev/null)
        echo -e "  ${BLUE}URL:${NC} $url"
        
        # Fetch latest info
        git fetch "$remote" --quiet 2>/dev/null || {
            warning "  Failed to fetch from $remote"
            continue
        }
        
        # Check if we're ahead/behind
        local ahead=$(git rev-list --count "$remote/$current_branch".."$current_branch" 2>/dev/null || echo "0")
        local behind=$(git rev-list --count "$current_branch".."$remote/$current_branch" 2>/dev/null || echo "0")
        
        if [[ "$ahead" -gt 0 && "$behind" -gt 0 ]]; then
            warning "  Diverged: $ahead ahead, $behind behind"
        elif [[ "$ahead" -gt 0 ]]; then
            info "  Ahead by $ahead commit(s)"
        elif [[ "$behind" -gt 0 ]]; then
            warning "  Behind by $behind commit(s)"
        else
            success "  Up to date"
        fi
        echo
    done
    
    # Local changes
    echo -e "${BOLD}Local Changes:${NC}"
    local changes=$(git status --porcelain)
    if [[ -z "$changes" ]]; then
        success "Working directory clean"
    else
        warning "Uncommitted changes:"
        git status --short
    fi
}

# Show version
cmd_version() {
    load_colors
    echo "Git-Go v${VERSION}"
}

# Setup wizard for first-time configuration
setup_wizard() {
    load_colors
    echo -e "${BOLD}Git-Go Setup Wizard${NC}\n"
    echo "Let's configure Git-Go for your environment."
    echo
    
    # Primary git service
    echo -e "${YELLOW}1. Primary Git Service${NC}"
    echo "Choose your primary git hosting service:"
    echo "  1) GitHub"
    echo "  2) GitLab"
    echo "  3) Bitbucket"
    echo "  4) Self-hosted"
    echo "  5) Other"
    read -p "Choice (1-5): " choice
    
    case $choice in
        1)
            PRIMARY_PREFIX="git@github.com:"
            PRIMARY_HOST="github.com"
            ;;
        2)
            PRIMARY_PREFIX="git@gitlab.com:"
            PRIMARY_HOST="gitlab.com"
            ;;
        3)
            PRIMARY_PREFIX="git@bitbucket.org:"
            PRIMARY_HOST="bitbucket.org"
            ;;
        4|5)
            read -p "Git server hostname: " PRIMARY_HOST
            read -p "Git URL prefix (e.g., git@example.com: or ssh://git@example.com/): " PRIMARY_PREFIX
            ;;
        *)
            PRIMARY_PREFIX="git@github.com:"
            PRIMARY_HOST="github.com"
            ;;
    esac
    
    # Username
    echo
    read -p "Your username on $PRIMARY_HOST [$USER]: " git_user
    PRIMARY_USER="${git_user:-$USER}"
    
    # Secondary remote
    echo
    read -p "Configure a secondary remote? (y/n) [n]: " setup_secondary
    if [[ "$setup_secondary" =~ ^[Yy]$ ]]; then
        echo
        read -p "Secondary git server hostname: " SECONDARY_HOST
        read -p "Secondary git URL prefix: " SECONDARY_PREFIX
        read -p "Your username on $SECONDARY_HOST [$PRIMARY_USER]: " sec_user
        SECONDARY_USER="${sec_user:-$PRIMARY_USER}"
    else
        SECONDARY_HOST=""
        SECONDARY_PREFIX=""
        SECONDARY_USER=""
    fi
    
    # Other settings
    echo
    echo -e "${YELLOW}2. Additional Settings${NC}"
    read -p "Enable VS Code integration? (y/n) [y]: " vscode
    ENABLE_VSCODE="${vscode:-y}"
    
    read -p "Create CLAUDE.md files for AI assistance? (y/n) [y]: " claude
    ENABLE_CLAUDE="${claude:-y}"
    
    # Create config
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" << EOF
# Git-Go Configuration
# Generated by setup wizard on $(date)

# Primary git server
GIT_PRIMARY_HOST="$PRIMARY_HOST"
GIT_PRIMARY_USER="$PRIMARY_USER"
GIT_PRIMARY_PREFIX="$PRIMARY_PREFIX"

# Secondary git server
GIT_SECONDARY_HOST="$SECONDARY_HOST"
GIT_SECONDARY_USER="$SECONDARY_USER"
GIT_SECONDARY_PREFIX="$SECONDARY_PREFIX"

# Default branch name
DEFAULT_BRANCH="main"

# Features
ENABLE_VSCODE_INTEGRATION=$([ "$ENABLE_VSCODE" = "y" ] && echo "true" || echo "false")
ENABLE_CLAUDE_MD=$([ "$ENABLE_CLAUDE" = "y" ] && echo "true" || echo "false")

# Default templates
DEFAULT_GITIGNORE_TEMPLATES="node,python"

# Colors
USE_COLORS=true
EOF
    
    success "Configuration saved to $CONFIG_FILE"
    echo
    echo "You can edit this file anytime with: git-go config"
}

# Show interactive menu
show_menu() {
    echo -e "${BOLD}Git-Go v${VERSION}${NC} - Intelligent Git Repository Manager\n"
    echo "What would you like to do?"
    echo
    echo -e "  ${BOLD}1)${NC} Create a new repository"
    echo -e "  ${BOLD}2)${NC} Fork an existing repository"
    echo -e "  ${BOLD}3)${NC} Edit configuration"
    echo -e "  ${BOLD}4)${NC} Run setup wizard"
    echo -e "  ${BOLD}5)${NC} Show version"
    echo -e "  ${BOLD}6)${NC} Show help"
    echo -e "  ${BOLD}7)${NC} Exit"
    echo
    read -p "Enter your choice (1-7): " choice
    
    case $choice in
        1)
            COMMAND="new"
            ;;
        2)
            COMMAND="fork"
            ;;
        3)
            COMMAND="config"
            ;;
        4)
            COMMAND="status"
            ;;
        5)
            COMMAND="setup"
            ;;
        6)
            COMMAND="version"
            ;;
        7)
            COMMAND="help"
            ;;
        8)
            echo "Goodbye!"
            exit 0
            ;;
        *)
            error "Invalid choice: $choice"
            exit 1
            ;;
    esac
}

# Main execution
main() {
    parse_args "$@"
    
    # If no command was provided, show interactive menu
    if [[ -z "$COMMAND" ]]; then
        # Check if config exists first
        if [[ ! -f "$CONFIG_FILE" ]]; then
            echo -e "${YELLOW}No configuration found. Running setup wizard...${NC}\n"
            setup_wizard
            echo
        fi
        load_config
        show_menu
    fi
    
    # Check if config exists (unless running setup/help/version)
    if [[ ! -f "$CONFIG_FILE" ]] && [[ ! "$COMMAND" =~ ^(setup|help|version|config)$ ]]; then
        echo -e "${YELLOW}No configuration found. Running setup wizard...${NC}\n"
        setup_wizard
        echo
    fi
    
    load_config
    
    # Ensure work directory exists
    mkdir -p "$WORK_DIR"
    
    case "$COMMAND" in
        new)
            cmd_new
            ;;
        fork)
            cmd_fork
            ;;
        config)
            cmd_config
            ;;
        status)
            cmd_status
            ;;
        setup)
            setup_wizard
            ;;
        version)
            cmd_version
            ;;
        help)
            usage
            ;;
        "")
            # Empty command is handled above by showing menu
            ;;
        *)
            error "Unknown command: $COMMAND"
            usage
            exit 1
            ;;
    esac
}

# Run main function
main "$@"