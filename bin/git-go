#!/bin/bash
#
# Git-Go - Intelligent Git Repository Manager
# https://github.com/USERNAME/git-go
#
# Create and manage git repositories with smart sync scripts,
# VS Code integration, and AI-assisted development support.
#

set -e

# Script directory and paths
# Check if we're running from a symlink
SCRIPT_PATH="${BASH_SOURCE[0]}"
if [[ -L "$SCRIPT_PATH" ]]; then
    # Follow the symlink to get the real script location
    SCRIPT_PATH="$(readlink -f "$SCRIPT_PATH")"
fi
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")/.." && pwd)"
LIB_DIR="$SCRIPT_DIR/lib"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/git-go"
CONFIG_FILE="$CONFIG_DIR/config"

# Version
VERSION="1.1.0"

# Library loading flags
COLORS_LOADED=false
GIT_UTILS_LOADED=false
PERF_UTILS_LOADED=false

# Lazy load color library
load_colors() {
    [[ "$COLORS_LOADED" == "true" ]] && return
    source "$LIB_DIR/colors.sh"
    COLORS_LOADED=true
}

# Lazy load git utils
load_git_utils() {
    [[ "$GIT_UTILS_LOADED" == "true" ]] && return
    source "$LIB_DIR/git-utils.sh"
    GIT_UTILS_LOADED=true
}

# Lazy load performance utils
load_perf_utils() {
    [[ "$PERF_UTILS_LOADED" == "true" ]] && return
    source "$LIB_DIR/performance-utils.sh"
    PERF_UTILS_LOADED=true
}

# Configuration cache
CONFIG_LOADED=false

# Load configuration
load_config() {
    # Skip if already loaded
    [[ "$CONFIG_LOADED" == "true" ]] && return
    
    # Default configuration
    GIT_PRIMARY_HOST="github.com"
    GIT_PRIMARY_USER="${USER}"
    GIT_PRIMARY_PREFIX="git@github.com:"
    GIT_SECONDARY_HOST=""
    GIT_SECONDARY_USER=""
    GIT_SECONDARY_PREFIX=""
    DEFAULT_BRANCH="main"
    ENABLE_VSCODE_INTEGRATION=true
    ENABLE_CLAUDE_MD=true
    DEFAULT_GITIGNORE_TEMPLATES="node,python"
    USE_COLORS=true
    DEFAULT_PARENT_DIR="$HOME/src"
    
    # Repo snippets configuration
    REPO_SNIPPETS_LOCAL="$HOME/src/repo-snippets"
    REPO_SNIPPETS_REMOTE="https://github.com/PowerAppsDarren/repo-snippets.git"
    ENABLE_REPO_SNIPPETS=true
    
    # User config copying
    COPY_VSCODE_CONFIG=true
    COPY_CURSOR_CONFIG=true
    COPY_CLAUDE_CONFIG=true
    
    # Hybrid architecture settings
    ENABLE_HYBRID=true  # Default to enabled for web apps
    HYBRID_TEMPLATE_DIR="$HOME/src/model-hybrid"
    
    # Load user config if exists
    [[ -f "$CONFIG_FILE" ]] && source "$CONFIG_FILE"
    
    # Set working directory (can be overridden by -d flag or DEFAULT_PARENT_DIR config)
    WORK_DIR="${WORK_DIR:-${DEFAULT_PARENT_DIR:-$HOME/src}}"
    
    # Mark as loaded
    CONFIG_LOADED=true
}

# Show usage
usage() {
    load_colors
    echo -e "${BOLD}Git-Go v${VERSION}${NC} - Intelligent Git Repository Manager

${BOLD}USAGE:${NC}
    git-go [OPTIONS] [COMMAND]

${BOLD}COMMANDS:${NC}
    new              Create a new repository
    fork             Fork an existing repository
    clone            Clone an existing repository
    config           Edit configuration
    status           Show repository sync status
    setup            Run setup wizard
    version          Show version information
    help             Show this help message

${BOLD}OPTIONS:${NC}
    -n, --name       Repository name (for new/fork)
    -u, --url        Repository URL (for fork)
    -d, --dir        Working directory (default: ~/src)
    --hybrid         Enable hybrid Electron/Web architecture for web apps (default)
    --no-hybrid      Disable hybrid architecture
    --dry-run        Validate inputs without creating anything
    -h, --help       Show help message

${BOLD}EXAMPLES:${NC}
    git-go new --name my-project
    git-go new --name my-webapp --hybrid       # Web app with desktop mode
    git-go new --name my-api --no-hybrid        # API service without desktop
    git-go fork --url https://github.com/user/repo
    git-go clone --url https://github.com/user/repo
    git-go config"
}

# Parse command line arguments
parse_args() {
    COMMAND=""
    REPO_NAME=""
    REPO_URL=""
    DRY_RUN=false
    ENABLE_HYBRID=""  # Empty means use default from config
    
    # Load colors for error messages
    load_colors
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            new|fork|clone|config|status|setup|version|help)
                COMMAND=$1
                shift
                ;;
            -n|--name)
                REPO_NAME="$2"
                shift 2
                ;;
            -u|--url)
                REPO_URL="$2"
                shift 2
                ;;
            -d|--dir)
                WORK_DIR="$2"
                shift 2
                ;;
            --hybrid)
                ENABLE_HYBRID="true"
                shift
                ;;
            --no-hybrid)
                ENABLE_HYBRID="false"
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
    
    # Don't default to anything - let main() handle it
}

# Create VS Code integration
create_vscode_integration() {
    local repo_dir=$1
    
    [[ "$ENABLE_VSCODE_INTEGRATION" != "true" ]] && return
    
    mkdir -p "$repo_dir/.vscode"
    
    cat > "$repo_dir/.vscode/tasks.json" << 'EOF'
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Git Sync",
            "type": "shell",
            "command": "${workspaceFolder}/scripts/sync.sh",
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "presentation": {
                "reveal": "always",
                "panel": "terminal"
            },
            "problemMatcher": []
        }
    ]
}
EOF
}

# Get application subtype based on type
get_app_subtype() {
    local app_type="$1"
    local subtype=""
    
    case "$app_type" in
        "Web Applications")
            cat >&2 <<EOF

${BOLD}Select Web Application Subtype:${NC}
  1) Static Sites (marketing pages, portfolios, documentation)
  2) Single Page Apps/SPAs (Gmail, Twitter, Spotify Web)
  3) Progressive Web Apps/PWAs (installable web apps with offline support)
  4) Server-Side Rendered/SSR (e-commerce, blogs, news sites)
  5) Jamstack Sites (static + APIs, Gatsby, Astro sites)
  6) Web-Based SaaS (Stripe Dashboard, Notion, Linear)
  7) Enterprise Web Apps (CRMs, ERPs, internal tools)
  8) E-commerce Platforms (Shopify stores, marketplaces)
  9) Social Networks (forums, communities, dating apps)
 10) Content Management Systems (WordPress, Ghost, Strapi)
 11) Learning Management Systems (course platforms, online schools)
 12) Real-time Collaboration (Google Docs, Figma, Miro)
 13) Dashboards/Analytics (admin panels, BI tools)
 14) Streaming Platforms (YouTube, Netflix web versions)
 15) Electron Apps (Web tech as desktop: VS Code, Discord)
 16) Other
EOF
            read -p "Choice (1-16): " choice >&2
            case "$choice" in
                1) subtype="Static Sites" ;;
                2) subtype="Single Page Apps/SPAs" ;;
                3) subtype="Progressive Web Apps/PWAs" ;;
                4) subtype="Server-Side Rendered/SSR" ;;
                5) subtype="Jamstack Sites" ;;
                6) subtype="Web-Based SaaS" ;;
                7) subtype="Enterprise Web Apps" ;;
                8) subtype="E-commerce Platforms" ;;
                9) subtype="Social Networks" ;;
                10) subtype="Content Management Systems" ;;
                11) subtype="Learning Management Systems" ;;
                12) subtype="Real-time Collaboration" ;;
                13) subtype="Dashboards/Analytics" ;;
                14) subtype="Streaming Platforms" ;;
                15) subtype="Electron Apps" ;;
                16) 
                    read -p "Enter custom web application subtype: " subtype >&2
                    [[ -z "$subtype" ]] && subtype="Custom Web Application"
                    ;;
                *) subtype="Web Application" ;;
            esac
            ;;
        "Mobile Applications")
            cat >&2 <<EOF

${BOLD}Select Mobile Application Subtype:${NC}
  1) Native iOS (Swift/SwiftUI apps)
  2) Native Android (Kotlin/Java apps)
  3) Cross-Platform Mobile (React Native, Flutter, Ionic)
  4) Hybrid Apps (Capacitor, Cordova - web wrapped as mobile)
  5) Mobile Games (Unity, native game engines)
  6) Other
EOF
            read -p "Choice (1-6): " choice >&2
            case "$choice" in
                1) subtype="Native iOS" ;;
                2) subtype="Native Android" ;;
                3) subtype="Cross-Platform Mobile" ;;
                4) subtype="Hybrid Apps" ;;
                5) subtype="Mobile Games" ;;
                6) 
                    read -p "Enter custom mobile application subtype: " subtype >&2
                    [[ -z "$subtype" ]] && subtype="Custom Mobile Application"
                    ;;
                *) subtype="Mobile Application" ;;
            esac
            ;;
        "Desktop Applications")
            cat >&2 <<EOF

${BOLD}Select Desktop Application Subtype:${NC}
  1) Electron Apps (VS Code, Discord, Slack)
  2) Native Windows (WPF, WinForms, UWP apps)
  3) Native macOS (Swift/AppKit apps)
  4) Native Linux (GTK, Qt applications)
  5) Cross-Platform Native (Tauri, Qt, JavaFX)
  6) Other
EOF
            read -p "Choice (1-6): " choice >&2
            case "$choice" in
                1) subtype="Electron Apps" ;;
                2) subtype="Native Windows" ;;
                3) subtype="Native macOS" ;;
                4) subtype="Native Linux" ;;
                5) subtype="Cross-Platform Native" ;;
                6) 
                    read -p "Enter custom desktop application subtype: " subtype >&2
                    [[ -z "$subtype" ]] && subtype="Custom Desktop Application"
                    ;;
                *) subtype="Desktop Application" ;;
            esac
            ;;
        "Command Line Applications")
            cat >&2 <<EOF

${BOLD}Select Command Line Application Subtype:${NC}
  1) CLI Tools (Git, npm, development tools)
  2) Terminal UIs/TUIs (htop, vim, terminal dashboards)
  3) Build Tools (Webpack, Vite, bundlers)
  4) Automation Scripts (Python/Bash/Node scripts)
  5) Other
EOF
            read -p "Choice (1-5): " choice >&2
            case "$choice" in
                1) subtype="CLI Tools" ;;
                2) subtype="Terminal UIs/TUIs" ;;
                3) subtype="Build Tools" ;;
                4) subtype="Automation Scripts" ;;
                5) 
                    read -p "Enter custom command line application subtype: " subtype >&2
                    [[ -z "$subtype" ]] && subtype="Custom Command Line Tool"
                    ;;
                *) subtype="Command Line Tool" ;;
            esac
            ;;
        "API/Backend Services")
            cat >&2 <<EOF

${BOLD}Select API/Backend Service Subtype:${NC}
  1) REST APIs (traditional HTTP services)
  2) GraphQL APIs (flexible query services)
  3) Microservices (distributed service architectures)
  4) Serverless Functions (Lambda, Vercel Functions)
  5) WebSocket Services (real-time communication)
  6) gRPC Services (high-performance RPC)
  7) Other
EOF
            read -p "Choice (1-7): " choice >&2
            case "$choice" in
                1) subtype="REST APIs" ;;
                2) subtype="GraphQL APIs" ;;
                3) subtype="Microservices" ;;
                4) subtype="Serverless Functions" ;;
                5) subtype="WebSocket Services" ;;
                6) subtype="gRPC Services" ;;
                7) 
                    read -p "Enter custom API/backend service subtype: " subtype >&2
                    [[ -z "$subtype" ]] && subtype="Custom API/Backend Service"
                    ;;
                *) subtype="API/Backend Service" ;;
            esac
            ;;
        "Game Development")
            cat >&2 <<EOF

${BOLD}Select Game Development Subtype:${NC}
  1) Browser Games (JavaScript/WebGL games)
  2) Mobile Games (iOS/Android native or Unity)
  3) PC Games (Steam, Epic Games)
  4) Console Games (PlayStation, Xbox, Nintendo)
  5) Other
EOF
            read -p "Choice (1-5): " choice >&2
            case "$choice" in
                1) subtype="Browser Games" ;;
                2) subtype="Mobile Games" ;;
                3) subtype="PC Games" ;;
                4) subtype="Console Games" ;;
                5) 
                    read -p "Enter custom game development subtype: " subtype >&2
                    [[ -z "$subtype" ]] && subtype="Custom Game"
                    ;;
                *) subtype="Game" ;;
            esac
            ;;
        "Embedded/IoT Applications")
            cat >&2 <<EOF

${BOLD}Select Embedded/IoT Application Subtype:${NC}
  1) Firmware (microcontroller programming)
  2) IoT Devices (smart home, industrial sensors)
  3) Automotive (car infotainment systems)
  4) Wearables (smartwatch apps)
  5) Other
EOF
            read -p "Choice (1-5): " choice >&2
            case "$choice" in
                1) subtype="Firmware" ;;
                2) subtype="IoT Devices" ;;
                3) subtype="Automotive" ;;
                4) subtype="Wearables" ;;
                5) 
                    read -p "Enter custom embedded/IoT application subtype: " subtype >&2
                    [[ -z "$subtype" ]] && subtype="Custom Embedded/IoT Application"
                    ;;
                *) subtype="Embedded/IoT Application" ;;
            esac
            ;;
        "Browser Extensions")
            cat >&2 <<EOF

${BOLD}Select Browser Extension Subtype:${NC}
  1) Chrome Extensions (ad blockers, productivity tools)
  2) Firefox Add-ons (privacy tools, themes)
  3) Safari Extensions (password managers)
  4) Other
EOF
            read -p "Choice (1-4): " choice >&2
            case "$choice" in
                1) subtype="Chrome Extensions" ;;
                2) subtype="Firefox Add-ons" ;;
                3) subtype="Safari Extensions" ;;
                4) 
                    read -p "Enter custom browser extension subtype: " subtype >&2
                    [[ -z "$subtype" ]] && subtype="Custom Browser Extension"
                    ;;
                *) subtype="Browser Extension" ;;
            esac
            ;;
        "AI/ML Applications")
            cat >&2 <<EOF

${BOLD}Select AI/ML Application Subtype:${NC}
  1) Chatbots (customer service, virtual assistants)
  2) Computer Vision (image recognition, filters)
  3) NLP Tools (translation, sentiment analysis)
  4) Recommendation Systems (Netflix, Amazon suggestions)
  5) Other
EOF
            read -p "Choice (1-5): " choice >&2
            case "$choice" in
                1) subtype="Chatbots" ;;
                2) subtype="Computer Vision" ;;
                3) subtype="NLP Tools" ;;
                4) subtype="Recommendation Systems" ;;
                5) 
                    read -p "Enter custom AI/ML application subtype: " subtype >&2
                    [[ -z "$subtype" ]] && subtype="Custom AI/ML Application"
                    ;;
                *) subtype="AI/ML Application" ;;
            esac
            ;;
        "Specialized Applications")
            cat >&2 <<EOF

${BOLD}Select Specialized Application Subtype:${NC}
  1) AR/VR Apps (Meta Quest, Apple Vision Pro)
  2) Blockchain/Web3 (DApps, smart contracts)
  3) Data Visualization (Tableau, D3.js apps)
  4) Scientific Computing (MATLAB, Jupyter notebooks)
  5) CAD/3D Software (AutoCAD, Blender plugins)
  6) Other
EOF
            read -p "Choice (1-6): " choice >&2
            case "$choice" in
                1) subtype="AR/VR Apps" ;;
                2) subtype="Blockchain/Web3" ;;
                3) subtype="Data Visualization" ;;
                4) subtype="Scientific Computing" ;;
                5) subtype="CAD/3D Software" ;;
                6) 
                    read -p "Enter custom specialized application subtype: " subtype >&2
                    [[ -z "$subtype" ]] && subtype="Custom Specialized Application"
                    ;;
                *) subtype="Specialized Application" ;;
            esac
            ;;
        *)
            subtype="Application"
            ;;
    esac
    
    echo "$subtype"
}

# Copy template files based on application type
copy_template_files() {
    local repo_dir=$1
    local repo_name=$2
    local app_type=$3
    local app_subtype=$4
    local app_description=${5:-"Add your project description here."}
    
    # Create README.md with application type information
    cat > "$repo_dir/README.md" << EOF
# $repo_name

**Application Type:** $app_type  
**Subtype:** $app_subtype

## Description

$app_description

## Getting Started

### Prerequisites

- List any prerequisites here

### Installation

\`\`\`bash
# Add installation steps
\`\`\`

### Usage

\`\`\`bash
# Add usage examples
\`\`\`

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details.
EOF
}

# Add hybrid Electron/Web architecture support
add_hybrid_architecture() {
    local repo_dir=$1
    local repo_name=$2
    local app_subtype=$3
    
    load_colors
    step "Adding hybrid Electron/Web architecture (new global standard)"
    
    # Check if model-hybrid template exists
    if [[ ! -d "$HYBRID_TEMPLATE_DIR" ]]; then
        warning "Hybrid template not found at $HYBRID_TEMPLATE_DIR"
        info "Run '/my-hybrid create-template' to create the template"
        return
    fi
    
    # Copy Electron structure
    if [[ -d "$HYBRID_TEMPLATE_DIR/electron" ]]; then
        cp -r "$HYBRID_TEMPLATE_DIR/electron" "$repo_dir/"
        success "Added Electron desktop runtime"
    fi
    
    # Copy electron-builder configuration
    if [[ -f "$HYBRID_TEMPLATE_DIR/electron-builder.yml" ]]; then
        cp "$HYBRID_TEMPLATE_DIR/electron-builder.yml" "$repo_dir/"
    fi
    
    # Create or update package.json with hybrid scripts
    if [[ ! -f "$repo_dir/package.json" ]]; then
        cat > "$repo_dir/package.json" << EOF
{
  "name": "$repo_name",
  "version": "1.0.0",
  "description": "$app_subtype - Hybrid Electron/Web Application",
  "main": "electron/main.js",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "electron": "electron .",
    "electron:dev": "concurrently \\"npm run dev\\" \\"wait-on http://localhost:5173 && electron .\\"",
    "hybrid": "concurrently \\"npm run dev\\" \\"npm run electron\\"",
    "dist": "npm run build && electron-builder",
    "dist:win": "npm run build && electron-builder --win",
    "dist:mac": "npm run build && electron-builder --mac",
    "dist:linux": "npm run build && electron-builder --linux"
  },
  "devDependencies": {
    "electron": "^28.0.0",
    "electron-builder": "^24.0.0",
    "vite": "^5.0.0",
    "concurrently": "^8.0.0",
    "wait-on": "^7.0.0"
  },
  "dependencies": {}
}
EOF
        success "Created package.json with hybrid scripts"
    else
        # Update existing package.json with hybrid scripts
        info "Updating existing package.json with hybrid scripts"
        # This would need a more sophisticated JSON merge, keeping simple for now
    fi
    
    # Create electron bridge for environment detection
    mkdir -p "$repo_dir/src/lib"
    cat > "$repo_dir/src/lib/electron-bridge.ts" << 'EOF'
// Electron Bridge - Detects if running in Electron or Web
export const isElectron = () => {
  return typeof window !== 'undefined' && 
         typeof window.process === 'object' && 
         window.process.type === 'renderer';
};

export const electronAPI = isElectron() ? window.electronAPI : null;

// Environment-aware configuration
export const getConfig = () => {
  if (isElectron()) {
    return {
      platform: 'desktop',
      features: {
        systemTray: true,
        globalHotkeys: true,
        fileSystem: true,
        notifications: 'native'
      }
    };
  }
  return {
    platform: 'web',
    features: {
      systemTray: false,
      globalHotkeys: false,
      fileSystem: false,
      notifications: 'browser'
    }
  };
};
EOF
    
    # Update CLAUDE.md with hybrid information
    if [[ -f "$repo_dir/CLAUDE.md" ]]; then
        cat >> "$repo_dir/CLAUDE.md" << 'EOF'

## 🚀 Hybrid Architecture

This project uses **HYBRID ELECTRON/WEB ARCHITECTURE** - the new global standard.

### Quick Start
- **Desktop Mode**: `npm run electron` (⚡ 200ms launch)
- **Web Mode**: `npm run dev` (🌐 Network accessible)
- **Hybrid Mode**: `npm run hybrid` (🚀 Both running simultaneously!)

### Benefits
- Desktop app with system tray and global hotkeys
- Web server for browser/mobile access  
- Shared codebase and database
- Smart environment detection via `src/lib/electron-bridge.ts`

### Building for Distribution
- Windows: `npm run dist:win`
- macOS: `npm run dist:mac`
- Linux: `npm run dist:linux`

See: ~/dev-knowledge/hybrid-electron-web-stack.md for full documentation
EOF
    fi
    
    success "✨ Hybrid Electron/Web architecture added successfully!"
    info "Your app can now run as both desktop (200ms load) and web application"
}

# Create claude.md file
create_claude_md() {
    local repo_dir=$1
    local repo_name=$2
    local app_type=$3
    local app_subtype=$4
    
    [[ "$ENABLE_CLAUDE_MD" != "true" ]] && return
    
    cat > "$repo_dir/CLAUDE.md" << EOF
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project: $repo_name

**Application Type:** $app_type  
**Subtype:** $app_subtype

### Quick Start
- Build: \`npm run build\` (update as needed)
- Test: \`npm test\` (update as needed)
- Lint: \`npm run lint\` (update as needed)

### Architecture Notes
<!-- Describe key architectural decisions and patterns -->

### Development Workflow
1. Make changes
2. Run tests
3. Use \`./scripts/sync.sh\` or Ctrl+Shift+B in VS Code to sync

### AI Assistant Guidelines
- Read relevant files before making changes
- Follow existing code patterns
- Consider impact on other components
- Suggest tests for new features
EOF
}

# Create sync script
create_sync_script() {
    local repo_dir=$1
    local repo_name=$2
    local is_fork=$3
    
    mkdir -p "$repo_dir/scripts"
    
    cat > "$repo_dir/scripts/sync.sh" << 'EOF'
#!/bin/bash
# Git sync script - generated by git-go

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Show repository status
echo -e "${BLUE}=== Git Sync ===${NC}"
echo -e "Repository: $(basename $(git rev-parse --show-toplevel))"
echo -e "Branch: $(git branch --show-current)"
echo -e "Status: $(git status --porcelain | wc -l) uncommitted changes"

# Check for uncommitted changes
if ! git diff-index --quiet HEAD -- 2>/dev/null; then
    echo -e "\n${YELLOW}You have uncommitted changes.${NC}"
    read -p "Stash them? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        git stash push -m "Auto-stash $(date +%Y%m%d-%H%M%S)"
        STASHED=true
    else
        echo -e "${RED}Cannot sync with uncommitted changes${NC}"
        exit 1
    fi
fi

# Get current branch
BRANCH=$(git branch --show-current)

EOF
    
    if [[ "$is_fork" == "true" ]]; then
        cat >> "$repo_dir/scripts/sync.sh" << 'EOF'
# Sync with upstream (for forks)
if git remote | grep -q upstream; then
    echo -e "\n${YELLOW}Fetching upstream...${NC}"
    git fetch upstream
    
    if git rev-list --count HEAD..upstream/$BRANCH &>/dev/null; then
        BEHIND=$(git rev-list --count HEAD..upstream/$BRANCH)
        if [[ $BEHIND -gt 0 ]]; then
            echo -e "${YELLOW}$BEHIND commits behind upstream${NC}"
            read -p "Merge upstream changes? (y/n) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                git merge upstream/$BRANCH -m "Merge upstream"
            fi
        fi
    fi
fi

EOF
    fi
    
    cat >> "$repo_dir/scripts/sync.sh" << 'EOF'
# Push to all remotes
for remote in $(git remote); do
    echo -e "\n${YELLOW}Pushing to $remote...${NC}"
    if git push $remote $BRANCH; then
        echo -e "${GREEN}✓ Pushed to $remote${NC}"
    else
        echo -e "${RED}✗ Failed to push to $remote${NC}"
    fi
done

# Restore stash if needed
if [[ "${STASHED:-false}" == "true" ]]; then
    echo
    read -p "Restore stashed changes? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        git stash pop
    fi
fi

echo -e "\n${GREEN}✅ Sync complete!${NC}"
EOF
    
    chmod +x "$repo_dir/scripts/sync.sh"
}

# Launch editor if available
launch_editor() {
    local repo_dir="$1"
    
    load_perf_utils
    
    if cached_command_exists cursor; then
        echo
        info "Launching Cursor..."
        # Simply open Cursor in the new project directory
        cursor "$repo_dir" &
        
        # Note: Cursor doesn't support CLI commands to open terminal or run commands
        # User will need to manually open terminal and run claudia
        echo
        info "After Cursor opens, you can:"
        echo "  1. Open terminal with Ctrl+\` (backtick)"
        echo "  2. Run 'claudia' to start Claude"
    elif cached_command_exists code; then
        echo
        info "Launching VS Code..."
        code "$repo_dir" &
    fi
}

# Setup git remotes and push initial commit
setup_and_push_remotes() {
    local repo_name="$1"
    
    step "Setting up remotes"
    
    # Setup remotes in parallel if both are configured
    local pids=()
    
    if [[ -n "$GIT_PRIMARY_PREFIX" ]]; then
        local primary_url="${GIT_PRIMARY_PREFIX}${GIT_PRIMARY_USER}/${repo_name}.git"
        {
            setup_remote "origin" "$primary_url"
        } &
        pids+=($!)
        info "Primary remote: $primary_url"
    fi
    
    if [[ -n "$GIT_SECONDARY_PREFIX" ]]; then
        local secondary_url="${GIT_SECONDARY_PREFIX}${GIT_SECONDARY_USER}/${repo_name}.git"
        {
            setup_remote "secondary" "$secondary_url"
        } &
        pids+=($!)
        info "Secondary remote: $secondary_url"
    fi
    
    # Wait for remote setup to complete
    for pid in "${pids[@]}"; do
        wait "$pid"
    done
    
    # Try to push
    if [[ -n "$GIT_PRIMARY_PREFIX" ]]; then
        step "Pushing to remotes"
        if git push -u origin "$DEFAULT_BRANCH" 2>&1; then
            success "Pushed to origin"
        else
            warning "Push to origin failed (this is normal if auto-create is disabled on your git server)"
        fi
    fi
}

# Create MIT LICENSE file
create_mit_license() {
    local repo_dir="$1"
    
    cat > "$repo_dir/LICENSE" << EOF
MIT License

Copyright (c) $(date +%Y) $GIT_PRIMARY_USER

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
EOF
}

# Create .gitignore file with common and template-specific patterns
create_gitignore() {
    local repo_dir="$1"
    
    cd "$repo_dir"
    touch .gitignore
    
    # Add common patterns
    cat >> .gitignore << 'EOF'
# OS
.DS_Store
Thumbs.db

# Editor
.vscode/*
!.vscode/tasks.json
.idea/
*.swp
*.swo

# Logs
*.log
logs/

# Environment
.env
.env.*
!.env.example
EOF
    
    # Add template-specific patterns
    if [[ -n "$DEFAULT_GITIGNORE_TEMPLATES" ]]; then
        IFS=',' read -ra TEMPLATES <<< "$DEFAULT_GITIGNORE_TEMPLATES"
        for template in "${TEMPLATES[@]}"; do
            case "$template" in
                node)
                    echo -e "\n# Node\nnode_modules/\ndist/\n.npm/" >> .gitignore
                    ;;
                python)
                    echo -e "\n# Python\n__pycache__/\n*.pyc\nvenv/\n.pytest_cache/" >> .gitignore
                    ;;
                go)
                    echo -e "\n# Go\n*.exe\n*.test\n*.out\nvendor/" >> .gitignore
                    ;;
            esac
        done
    fi
}

# Copy template files from repo-snippets
copy_repo_snippets() {
    local repo_dir=$1
    local repo_name=$2
    
    [[ "$ENABLE_REPO_SNIPPETS" != "true" ]] && return
    
    local snippets_dir=""
    
    # Check if local repo-snippets exists
    if [[ -d "$REPO_SNIPPETS_LOCAL" ]]; then
        snippets_dir="$REPO_SNIPPETS_LOCAL"
        info "Using local repo-snippets from $snippets_dir"
    elif [[ -n "$REPO_SNIPPETS_REMOTE" ]]; then
        # Clone to temp directory if remote is configured
        snippets_dir="/tmp/repo-snippets-$$"
        info "Cloning repo-snippets from remote..."
        if git clone --quiet --depth 1 --single-branch "$REPO_SNIPPETS_REMOTE" "$snippets_dir" 2>/dev/null; then
            info "Successfully cloned repo-snippets"
        else
            warning "Failed to clone repo-snippets from $REPO_SNIPPETS_REMOTE"
            return
        fi
    else
        warning "No repo-snippets source configured"
        return
    fi
    
    # Copy template files
    step "Copying template files from repo-snippets"
    
    # Use performance utils for optimized copy
    load_perf_utils
    
    # Batch copy operations
    local files_copied=false
    
    # Copy ai-chats directory structure
    if [[ -d "$snippets_dir/ai-chats" ]]; then
        optimized_copy "$snippets_dir/ai-chats" "$repo_dir" && files_copied=true
        # Clear out example session files but keep the structure
        find "$repo_dir/ai-chats" -name "2025-*.md" -delete 2>/dev/null || true
    fi
    
    # Copy dev-knowledge directory
    [[ -d "$snippets_dir/dev-knowledge" ]] && optimized_copy "$snippets_dir/dev-knowledge" "$repo_dir" && files_copied=true
    
    # Copy enhanced scripts (overwriting the basic ones)
    if [[ -f "$snippets_dir/scripts/sync.sh" ]]; then
        cp "$snippets_dir/scripts/sync.sh" "$repo_dir/scripts/sync.sh"
        chmod +x "$repo_dir/scripts/sync.sh"
        files_copied=true
    fi
    
    if [[ -f "$snippets_dir/scripts/pushall.sh" ]]; then
        cp "$snippets_dir/scripts/pushall.sh" "$repo_dir/scripts/"
        chmod +x "$repo_dir/scripts/pushall.sh"
        files_copied=true
    fi
    
    [[ "$files_copied" == "true" ]] && info "Template files copied from repo-snippets"
    
    # Copy CLAUDE.md if it exists (will be merged with generated one)
    if [[ -f "$snippets_dir/CLAUDE.md" ]] && [[ -f "$repo_dir/CLAUDE.md" ]]; then
        # Append repo-snippets CLAUDE.md content to the generated one
        echo -e "\n\n# Additional Instructions from repo-snippets\n" >> "$repo_dir/CLAUDE.md"
        cat "$snippets_dir/CLAUDE.md" >> "$repo_dir/CLAUDE.md"
        info "Merged CLAUDE.md instructions"
    fi
    
    # Clean up temp directory if we cloned
    if [[ "$snippets_dir" == "/tmp/repo-snippets-"* ]]; then
        rm -rf "$snippets_dir"
    fi
    
    success "Template files copied from repo-snippets"
}

# Copy user configuration files from home directory
copy_user_configs() {
    local repo_dir=$1
    
    step "Copying user configuration files"
    
    # Copy VS Code config if enabled and exists
    if [[ "$COPY_VSCODE_CONFIG" == "true" ]] && [[ -d "$HOME/.vscode" ]]; then
        info "Copying VS Code configuration..."
        
        # Copy settings.json, keybindings.json, extensions.json
        for config_file in settings.json keybindings.json extensions.json; do
            if [[ -f "$HOME/.vscode/$config_file" ]]; then
                cp "$HOME/.vscode/$config_file" "$repo_dir/.vscode/" 2>/dev/null || warning "Could not copy .vscode/$config_file"
            fi
        done
        
        # Handle tasks.json specially - merge with existing git-go task
        if [[ -f "$HOME/.vscode/tasks.json" ]]; then
            merge_tasks_json "$HOME/.vscode/tasks.json" "$repo_dir/.vscode/tasks.json"
        fi
    fi
    
    # Copy Cursor config if enabled and exists
    if [[ "$COPY_CURSOR_CONFIG" == "true" ]] && [[ -d "$HOME/.cursor" ]]; then
        info "Copying Cursor configuration..."
        
        # Create .cursor directory in repo
        mkdir -p "$repo_dir/.cursor"
        
        # Copy settings.json, keybindings.json, extensions.json, mcp.json
        for config_file in settings.json keybindings.json extensions.json mcp.json; do
            if [[ -f "$HOME/.cursor/$config_file" ]]; then
                cp "$HOME/.cursor/$config_file" "$repo_dir/.cursor/" 2>/dev/null || warning "Could not copy .cursor/$config_file"
            fi
        done
        
        # Handle tasks.json specially - merge with user cursor tasks
        if [[ -f "$HOME/.cursor/tasks.json" ]]; then
            cp "$HOME/.cursor/tasks.json" "$repo_dir/.cursor/tasks.json" 2>/dev/null || warning "Could not copy .cursor/tasks.json"
        fi
    fi
    
    # Copy Claude config if enabled and exists
    if [[ "$COPY_CLAUDE_CONFIG" == "true" ]] && [[ -d "$HOME/.claude" ]]; then
        info "Copying Claude Code configuration..."
        
        # Create .claude directory in repo and copy contents
        if cp -r "$HOME/.claude" "$repo_dir/" 2>/dev/null; then
            info "Copied .claude directory"
        else
            warning "Could not copy .claude directory"
        fi
    fi
    
    success "User configuration files copied"
}

# Merge tasks.json files to preserve git-go sync task while adding user tasks
merge_tasks_json() {
    local user_tasks_file="$1"
    local repo_tasks_file="$2"
    
    # Check if jq is available for JSON manipulation (use cached check)
    load_perf_utils
    if ! cached_command_exists jq; then
        warning "jq not available, skipping tasks.json merge"
        return
    fi
    
    # Create a temporary merged file
    local temp_file="/tmp/merged_tasks_$$.json"
    
    # Extract user tasks (excluding any existing "Git Sync" tasks)
    local user_tasks=$(jq -r '.tasks[] | select(.label != "Git Sync")' "$user_tasks_file" 2>/dev/null)
    
    # If we have user tasks, merge them with the git-go task
    if [[ -n "$user_tasks" && "$user_tasks" != "null" ]]; then
        # Create merged JSON with git-go sync task first, then user tasks
        jq --argjson user_tasks "$(jq '[.tasks[] | select(.label != "Git Sync")]' "$user_tasks_file" 2>/dev/null || echo '[]')" \
           '.tasks = (.tasks + $user_tasks)' "$repo_tasks_file" > "$temp_file" 2>/dev/null
        
        if [[ -s "$temp_file" ]]; then
            mv "$temp_file" "$repo_tasks_file"
            info "Merged user tasks with git-go sync task"
        else
            warning "Failed to merge tasks.json files"
            rm -f "$temp_file"
        fi
    fi
}

# Select application type interactively
select_application_type() {
    cat <<EOF

${BOLD}Select Application Type:${NC}
  1) Web Applications
  2) Mobile Applications
  3) Desktop Applications
  4) Command Line Applications
  5) API/Backend Services
  6) Game Development
  7) Embedded/IoT Applications
  8) Browser Extensions
  9) AI/ML Applications
 10) Specialized Applications
 11) Other
EOF
    read -p "Choice (1-11): " app_choice
    
    case "$app_choice" in
        1) SELECTED_APP_TYPE="Web Applications" ;;
        2) SELECTED_APP_TYPE="Mobile Applications" ;;
        3) SELECTED_APP_TYPE="Desktop Applications" ;;
        4) SELECTED_APP_TYPE="Command Line Applications" ;;
        5) SELECTED_APP_TYPE="API/Backend Services" ;;
        6) SELECTED_APP_TYPE="Game Development" ;;
        7) SELECTED_APP_TYPE="Embedded/IoT Applications" ;;
        8) SELECTED_APP_TYPE="Browser Extensions" ;;
        9) SELECTED_APP_TYPE="AI/ML Applications" ;;
        10) SELECTED_APP_TYPE="Specialized Applications" ;;
        11) 
            read -p "Enter custom application type: " SELECTED_APP_TYPE
            [[ -z "$SELECTED_APP_TYPE" ]] && SELECTED_APP_TYPE="Custom Application"
            ;;
        *) SELECTED_APP_TYPE="General Application" ;;
    esac
    
    # Get subtype based on type (skip for custom types)
    if [[ "$app_choice" == "11" ]] || [[ "$SELECTED_APP_TYPE" == "Custom Application" ]]; then
        SELECTED_APP_SUBTYPE="$SELECTED_APP_TYPE"
    else
        SELECTED_APP_SUBTYPE=$(get_app_subtype "$SELECTED_APP_TYPE")
    fi
    
    # Get application description
    echo
    echo -e "${BOLD}What is this application for?${NC}"
    echo "(Describe the purpose and functionality of your application)"
    read -p "> " SELECTED_APP_DESCRIPTION
}

# Create a new repository
cmd_new() {
    load_colors
    load_git_utils
    
    local repo_name="$REPO_NAME"
    local app_type=""
    local app_subtype=""
    local app_description=""
    local parent_dir=""
    
    # Interactive mode if name not provided
    if [[ -z "$repo_name" ]]; then
        # In dry-run mode, we need a name
        if [[ "$DRY_RUN" == "true" ]]; then
            error "New command requires --name parameter"
            exit 1
        fi
        echo -e "${BOLD}Create New Repository${NC}\n"
        read -p "Repository name: " repo_name
    fi
    
    # Validate name
    if ! validate_repo_name "$repo_name"; then
        error "Invalid repository name. Use only letters, numbers, dots, hyphens, and underscores."
        exit 1
    fi
    
    # Ask for application type (only in interactive mode)
    if [[ "$DRY_RUN" != "true" ]]; then
        select_application_type
        app_type="$SELECTED_APP_TYPE"
        app_subtype="$SELECTED_APP_SUBTYPE"
        app_description="$SELECTED_APP_DESCRIPTION"
        
        # Ask for parent directory
        echo
        echo -e "${BOLD}Where should this repository be created?${NC}"
        echo -e "Default parent directory: ${CYAN}$WORK_DIR${NC}"
        read -p "Parent directory (press Enter to use default): " custom_parent
        parent_dir="${custom_parent:-$WORK_DIR}"
        
        # Expand tilde if present
        parent_dir="${parent_dir/#\~/$HOME}"
        
        # Create parent directory if it doesn't exist
        if [[ ! -d "$parent_dir" ]]; then
            echo -e "${YELLOW}Directory $parent_dir doesn't exist.${NC}"
            read -p "Create it? (y/n) [y]: " create_dir
            if [[ "${create_dir:-y}" =~ ^[Yy]$ ]]; then
                mkdir -p "$parent_dir"
                success "Created parent directory: $parent_dir"
            else
                error "Cannot proceed without parent directory"
                exit 1
            fi
        fi
    else
        parent_dir="$WORK_DIR"
    fi
    
    # If dry-run, just validate and exit
    if [[ "$DRY_RUN" == "true" ]]; then
        success "Validation passed for repository name: $repo_name"
        exit 0
    fi
    
    local repo_dir="$parent_dir/$repo_name"
    
    # Check if already exists
    if [[ -d "$repo_dir" ]]; then
        error "Directory $repo_dir already exists!"
        exit 1
    fi
    
    # Create repository
    step "Creating repository at $repo_dir"
    mkdir -p "$repo_dir"
    cd "$repo_dir"
    
    git init -b "$DEFAULT_BRANCH"
    
    # Create initial files
    step "Creating initial files"
    
    # Use copy_template_files to create README.md with app type info
    copy_template_files "$repo_dir" "$repo_name" "$app_type" "$app_subtype" "$app_description"
    
    # Create .gitignore
    create_gitignore "$repo_dir"
    
    # Create LICENSE
    create_mit_license "$repo_dir"
    
    # Create VS Code integration
    create_vscode_integration "$repo_dir"
    
    # Create claude.md
    create_claude_md "$repo_dir" "$repo_name" "$app_type" "$app_subtype"
    
    # Create sync script
    create_sync_script "$repo_dir" "$repo_name" "false"
    
    # Copy template files from repo-snippets
    copy_repo_snippets "$repo_dir" "$repo_name"
    
    # Copy user configuration files
    copy_user_configs "$repo_dir"
    
    # Add hybrid architecture support for web applications
    if [[ "$app_type" == "Web Applications" ]] && [[ "$ENABLE_HYBRID" != "false" ]]; then
        add_hybrid_architecture "$repo_dir" "$repo_name" "$app_subtype"
    fi
    
    # Initial commit - batch add all files at once
    load_perf_utils
    git add . 2>/dev/null
    git commit -m "Initial commit"
    
    # Setup remotes and push
    setup_and_push_remotes "$repo_name"
    
    success "Repository created successfully!"
    echo
    highlight "Next steps:"
    echo "  cd $repo_dir"
    echo "  # Start coding!"
    echo "  ./scripts/sync.sh  # or Ctrl+Shift+B in VS Code"
    
    # Launch editor if available
    launch_editor "$repo_dir"
}

# Clone a repository (without fork setup)
cmd_clone() {
    load_colors
    load_git_utils
    
    local repo_url="$REPO_URL"
    local parent_dir=""
    
    # Interactive mode if URL not provided
    if [[ -z "$repo_url" ]]; then
        # In dry-run mode, we need a URL
        if [[ "$DRY_RUN" == "true" ]]; then
            error "Clone command requires --url parameter"
            exit 1
        fi
        echo -e "${BOLD}Clone Repository${NC}\n"
        read -p "Repository URL: " repo_url
    fi
    
    # Extract repo info
    local repo_info=$(extract_repo_info "$repo_url")
    local author=$(echo "$repo_info" | cut -d'|' -f1)
    local repo=$(echo "$repo_info" | cut -d'|' -f2)
    
    if [[ -z "$author" ]] || [[ -z "$repo" ]]; then
        error "Could not parse repository URL"
        exit 1
    fi
    
    # If dry-run, just validate and exit
    if [[ "$DRY_RUN" == "true" ]]; then
        success "Validation passed for clone URL: $repo_url"
        exit 0
    fi
    
    # Use provided name or use original
    local repo_name="${REPO_NAME:-$repo}"
    
    # Ask for parent directory (only in interactive mode)
    if [[ "$DRY_RUN" != "true" ]]; then
        echo
        echo -e "${BOLD}Where should this repository be cloned?${NC}"
        echo -e "Default parent directory: ${CYAN}$WORK_DIR${NC}"
        read -p "Parent directory (press Enter to use default): " custom_parent
        parent_dir="${custom_parent:-$WORK_DIR}"
        
        # Expand tilde if present
        parent_dir="${parent_dir/#\~/$HOME}"
        
        # Create parent directory if it doesn't exist
        if [[ ! -d "$parent_dir" ]]; then
            echo -e "${YELLOW}Directory $parent_dir doesn't exist.${NC}"
            read -p "Create it? (y/n) [y]: " create_dir
            if [[ "${create_dir:-y}" =~ ^[Yy]$ ]]; then
                mkdir -p "$parent_dir"
                success "Created parent directory: $parent_dir"
            else
                error "Cannot proceed without parent directory"
                exit 1
            fi
        fi
    else
        parent_dir="$WORK_DIR"
    fi
    
    local repo_dir="$parent_dir/$repo_name"
    
    # Check if already exists
    if [[ -d "$repo_dir" ]]; then
        error "Directory $repo_dir already exists!"
        exit 1
    fi
    
    # Handle GitHub authentication if needed
    local auth_url="$repo_url"
    if [[ "$repo_url" =~ github\.com ]]; then
        # Check if we have a GitHub PAT stored
        if [[ -f "$HOME/.config/git-go/github_pat" ]]; then
            local github_pat=$(cat "$HOME/.config/git-go/github_pat")
            # Convert URL to include PAT
            auth_url=$(echo "$repo_url" | sed "s|https://github.com|https://${github_pat}@github.com|")
            info "Using stored GitHub PAT for authentication"
        else
            echo
            echo -e "${YELLOW}⚠️  GitHub requires Personal Access Token (PAT) for private repos${NC}"
            echo -e "${CYAN}📝 Instructions:${NC}"
            echo -e "   1. Go to: https://github.com/settings/tokens"
            echo -e "   2. Generate a new token with 'repo' scope"
            echo -e "   3. Paste the token below (it will be hidden)"
            echo
            read -s -p "GitHub PAT (or press Enter to skip): " github_pat
            echo
            
            if [[ -n "$github_pat" ]]; then
                # Store PAT for future use (optional)
                read -p "Save PAT for future use? (y/n) [y]: " save_pat
                if [[ "${save_pat:-y}" =~ ^[Yy]$ ]]; then
                    mkdir -p "$HOME/.config/git-go"
                    echo "$github_pat" > "$HOME/.config/git-go/github_pat"
                    chmod 600 "$HOME/.config/git-go/github_pat"
                    success "✅ PAT saved securely"
                fi
                # Convert URL to include PAT
                auth_url=$(echo "$repo_url" | sed "s|https://github.com|https://${github_pat}@github.com|")
            fi
        fi
    fi
    
    # Clone repository
    step "Cloning $repo_url"
    if ! git clone "$auth_url" "$repo_dir" 2>/dev/null; then
        # If clone fails, try without authentication
        warning "Clone with authentication failed, trying without..."
        git clone "$repo_url" "$repo_dir"
    fi
    cd "$repo_dir"
    
    # Create VS Code integration
    create_vscode_integration "$repo_dir"
    
    # Create claude.md (basic for clone)
    if [[ "$ENABLE_CLAUDE_MD" == "true" ]]; then
        cat > "$repo_dir/CLAUDE.md" << EOF
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project: $repo_name

Cloned from: $repo_url

### Development Workflow
1. Make changes
2. Run tests
3. Commit and push changes

### AI Assistant Guidelines
- Read relevant files before making changes
- Follow existing code patterns
- Consider impact on other components
- Suggest tests for new features
EOF
    fi
    
    # Create simple sync script for cloned repos
    mkdir -p "$repo_dir/scripts"
    cat > "$repo_dir/scripts/sync.sh" << 'EOF'
#!/bin/bash
# Git sync script for cloned repository - generated by git-go

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}=== Git Sync ===${NC}"
echo -e "Repository: $(basename $(git rev-parse --show-toplevel))"
echo -e "Branch: $(git branch --show-current)"

# Pull latest changes
echo -e "\n${YELLOW}Pulling latest changes...${NC}"
if git pull; then
    echo -e "${GREEN}✓ Pull successful${NC}"
else
    echo -e "${RED}✗ Pull failed${NC}"
    exit 1
fi

# Push any local commits
echo -e "\n${YELLOW}Pushing local changes...${NC}"
if git push; then
    echo -e "${GREEN}✓ Push successful${NC}"
else
    echo -e "${YELLOW}No changes to push or push failed${NC}"
fi

echo -e "\n${GREEN}✅ Sync complete!${NC}"
EOF
    chmod +x "$repo_dir/scripts/sync.sh"
    
    # Copy user configuration files
    copy_user_configs "$repo_dir"
    
    success "Repository cloned successfully!"
    echo
    highlight "Next steps:"
    echo "  cd $repo_dir"
    echo "  # Start working with the code"
    echo "  ./scripts/sync.sh  # Sync with remote"
    
    # Launch editor if available
    launch_editor "$repo_dir"
}

# Fork a repository
cmd_fork() {
    load_colors
    load_git_utils
    
    local repo_url="$REPO_URL"
    local parent_dir=""
    
    # Interactive mode if URL not provided
    if [[ -z "$repo_url" ]]; then
        # In dry-run mode, we need a URL
        if [[ "$DRY_RUN" == "true" ]]; then
            error "Fork command requires --url parameter"
            exit 1
        fi
        echo -e "${BOLD}Fork Repository${NC}\n"
        read -p "Repository URL: " repo_url
    fi
    
    # Extract repo info
    local repo_info=$(extract_repo_info "$repo_url")
    local author=$(echo "$repo_info" | cut -d'|' -f1)
    local repo=$(echo "$repo_info" | cut -d'|' -f2)
    
    if [[ -z "$author" ]] || [[ -z "$repo" ]]; then
        error "Could not parse repository URL"
        exit 1
    fi
    
    # If dry-run, just validate and exit
    if [[ "$DRY_RUN" == "true" ]]; then
        success "Validation passed for fork URL: $repo_url"
        exit 0
    fi
    
    # Use provided name or ask for it
    local repo_name="$REPO_NAME"
    if [[ -z "$repo_name" ]] && [[ "$DRY_RUN" != "true" ]]; then
        echo
        read -p "Repository name (press Enter to use '$repo'): " custom_name
        repo_name="${custom_name:-$repo}"
    elif [[ -z "$repo_name" ]]; then
        # For dry-run, use the original repo name
        repo_name="$repo"
    fi
    
    # Ask for parent directory (only in interactive mode)
    if [[ "$DRY_RUN" != "true" ]]; then
        echo
        echo -e "${BOLD}Where should this repository be cloned?${NC}"
        echo -e "Default parent directory: ${CYAN}$WORK_DIR${NC}"
        read -p "Parent directory (press Enter to use default): " custom_parent
        parent_dir="${custom_parent:-$WORK_DIR}"
        
        # Expand tilde if present
        parent_dir="${parent_dir/#\~/$HOME}"
        
        # Create parent directory if it doesn't exist
        if [[ ! -d "$parent_dir" ]]; then
            echo -e "${YELLOW}Directory $parent_dir doesn't exist.${NC}"
            read -p "Create it? (y/n) [y]: " create_dir
            if [[ "${create_dir:-y}" =~ ^[Yy]$ ]]; then
                mkdir -p "$parent_dir"
                success "Created parent directory: $parent_dir"
            else
                error "Cannot proceed without parent directory"
                exit 1
            fi
        fi
    else
        parent_dir="$WORK_DIR"
    fi
    
    local repo_dir="$parent_dir/$repo_name"
    
    # Check if already exists
    if [[ -d "$repo_dir" ]]; then
        error "Directory $repo_dir already exists!"
        exit 1
    fi
    
    # Handle GitHub authentication if needed
    local auth_url="$repo_url"
    if [[ "$repo_url" =~ github\.com ]]; then
        # Check if we have a GitHub PAT stored
        if [[ -f "$HOME/.config/git-go/github_pat" ]]; then
            local github_pat=$(cat "$HOME/.config/git-go/github_pat")
            # Convert URL to include PAT
            auth_url=$(echo "$repo_url" | sed "s|https://github.com|https://${github_pat}@github.com|")
            info "Using stored GitHub PAT for authentication"
        else
            echo
            echo -e "${YELLOW}⚠️  GitHub requires Personal Access Token (PAT) for private repos${NC}"
            echo -e "${CYAN}📝 Instructions:${NC}"
            echo -e "   1. Go to: https://github.com/settings/tokens"
            echo -e "   2. Generate a new token with 'repo' scope"
            echo -e "   3. Paste the token below (it will be hidden)"
            echo
            read -s -p "GitHub PAT (or press Enter to skip): " github_pat
            echo
            
            if [[ -n "$github_pat" ]]; then
                # Store PAT for future use (optional)
                read -p "Save PAT for future use? (y/n) [y]: " save_pat
                if [[ "${save_pat:-y}" =~ ^[Yy]$ ]]; then
                    mkdir -p "$HOME/.config/git-go"
                    echo "$github_pat" > "$HOME/.config/git-go/github_pat"
                    chmod 600 "$HOME/.config/git-go/github_pat"
                    success "✅ PAT saved securely"
                fi
                # Convert URL to include PAT
                auth_url=$(echo "$repo_url" | sed "s|https://github.com|https://${github_pat}@github.com|")
            fi
        fi
    fi
    
    # Clone repository
    step "Cloning $repo_url"
    if ! git clone "$auth_url" "$repo_dir" 2>/dev/null; then
        # If clone fails, try without authentication
        warning "Clone with authentication failed, trying without..."
        git clone "$repo_url" "$repo_dir"
    fi
    cd "$repo_dir"
    
    # Get default branch
    local default_branch=$(get_default_branch origin)
    
    # Setup remotes
    step "Setting up remotes"
    git remote rename origin upstream
    
    if [[ -n "$GIT_PRIMARY_PREFIX" ]]; then
        local primary_url="${GIT_PRIMARY_PREFIX}${GIT_PRIMARY_USER}/${repo_name}.git"
        setup_remote "origin" "$primary_url"
        info "Primary remote: $primary_url"
    fi
    
    if [[ -n "$GIT_SECONDARY_PREFIX" ]]; then
        local secondary_url="${GIT_SECONDARY_PREFIX}${GIT_SECONDARY_USER}/${repo_name}.git"
        setup_remote "secondary" "$secondary_url"
        info "Secondary remote: $secondary_url"
    fi
    
    # Create VS Code integration
    create_vscode_integration "$repo_dir"
    
    # Create claude.md (for fork)
    create_claude_md "$repo_dir" "$repo_name" "" ""
    
    # Create sync script
    create_sync_script "$repo_dir" "$repo_name" "true"
    
    # Copy user configuration files
    copy_user_configs "$repo_dir"
    
    # Try to push
    if [[ -n "$GIT_PRIMARY_PREFIX" ]]; then
        step "Pushing to your remotes"
        if git push -u origin "$default_branch" 2>/dev/null; then
            success "Pushed to origin"
        else
            warning "Could not push to origin. Create the repository first."
        fi
    fi
    
    success "Fork created successfully!"
    echo
    highlight "Next steps:"
    echo "  cd $repo_dir"
    echo "  # Make your changes"
    echo "  ./scripts/sync.sh  # Sync with upstream and your remotes"
    
    # Launch editor if available
    launch_editor "$repo_dir"
}

# Edit configuration
cmd_config() {
    load_colors
    # Create config directory if needed
    mkdir -p "$CONFIG_DIR"
    
    # Copy example if no config exists
    if [[ ! -f "$CONFIG_FILE" ]]; then
        cp "$SCRIPT_DIR/config/git-go.conf.example" "$CONFIG_FILE"
        info "Created configuration file at $CONFIG_FILE"
    fi
    
    # Open in editor
    load_perf_utils
    
    if [[ -n "$EDITOR" ]]; then
        $EDITOR "$CONFIG_FILE"
    elif cached_command_exists code; then
        code "$CONFIG_FILE"
    elif cached_command_exists nano; then
        nano "$CONFIG_FILE"
    else
        vi "$CONFIG_FILE"
    fi
}

# Show repository status across remotes
cmd_status() {
    load_colors
    load_git_utils
    
    # Check if we're in a git repository
    if ! is_git_repo; then
        error "Not in a git repository"
        exit 1
    fi
    
    echo -e "${BOLD}Git-Go Repository Status${NC}\n"
    
    # Current branch
    local current_branch=$(get_current_branch)
    echo -e "${CYAN}Current Branch:${NC} $current_branch"
    echo
    
    # Check each remote
    local remotes=$(git remote)
    if [[ -z "$remotes" ]]; then
        warning "No remotes configured"
        return
    fi
    
    for remote in $remotes; do
        echo -e "${BOLD}Remote: $remote${NC}"
        local url=$(git remote get-url "$remote" 2>/dev/null)
        echo -e "  ${BLUE}URL:${NC} $url"
        
        # Fetch latest info
        git fetch "$remote" --quiet 2>/dev/null || {
            warning "  Failed to fetch from $remote"
            continue
        }
        
        # Check if we're ahead/behind
        local ahead=$(git rev-list --count "$remote/$current_branch".."$current_branch" 2>/dev/null || echo "0")
        local behind=$(git rev-list --count "$current_branch".."$remote/$current_branch" 2>/dev/null || echo "0")
        
        if [[ "$ahead" -gt 0 && "$behind" -gt 0 ]]; then
            warning "  Diverged: $ahead ahead, $behind behind"
        elif [[ "$ahead" -gt 0 ]]; then
            info "  Ahead by $ahead commit(s)"
        elif [[ "$behind" -gt 0 ]]; then
            warning "  Behind by $behind commit(s)"
        else
            success "  Up to date"
        fi
        echo
    done
    
    # Local changes
    echo -e "${BOLD}Local Changes:${NC}"
    local changes=$(git status --porcelain)
    if [[ -z "$changes" ]]; then
        success "Working directory clean"
    else
        warning "Uncommitted changes:"
        git status --short
    fi
}

# Show version
cmd_version() {
    load_colors
    echo "Git-Go v${VERSION}"
}

# Setup wizard for first-time configuration
setup_wizard() {
    load_colors
    echo -e "${BOLD}Git-Go Setup Wizard${NC}\n"
    echo "Let's configure Git-Go for your environment."
    echo
    
    # Primary git service
    echo -e "${YELLOW}1. Primary Git Service${NC}"
    echo "Choose your primary git hosting service:"
    echo "  1) GitHub"
    echo "  2) GitLab"
    echo "  3) Bitbucket"
    echo "  4) Self-hosted"
    echo "  5) Other"
    read -p "Choice (1-5): " choice
    
    case $choice in
        1)
            PRIMARY_PREFIX="git@github.com:"
            PRIMARY_HOST="github.com"
            ;;
        2)
            PRIMARY_PREFIX="git@gitlab.com:"
            PRIMARY_HOST="gitlab.com"
            ;;
        3)
            PRIMARY_PREFIX="git@bitbucket.org:"
            PRIMARY_HOST="bitbucket.org"
            ;;
        4|5)
            read -p "Git server hostname: " PRIMARY_HOST
            read -p "Git URL prefix (e.g., git@example.com: or ssh://git@example.com/): " PRIMARY_PREFIX
            ;;
        *)
            PRIMARY_PREFIX="git@github.com:"
            PRIMARY_HOST="github.com"
            ;;
    esac
    
    # Username
    echo
    read -p "Your username on $PRIMARY_HOST [$USER]: " git_user
    PRIMARY_USER="${git_user:-$USER}"
    
    # Secondary remote
    echo
    read -p "Configure a secondary remote? (y/n) [n]: " setup_secondary
    if [[ "$setup_secondary" =~ ^[Yy]$ ]]; then
        echo
        read -p "Secondary git server hostname: " SECONDARY_HOST
        read -p "Secondary git URL prefix: " SECONDARY_PREFIX
        read -p "Your username on $SECONDARY_HOST [$PRIMARY_USER]: " sec_user
        SECONDARY_USER="${sec_user:-$PRIMARY_USER}"
    else
        SECONDARY_HOST=""
        SECONDARY_PREFIX=""
        SECONDARY_USER=""
    fi
    
    # Other settings
    echo
    echo -e "${YELLOW}2. Repository Settings${NC}"
    read -p "Default parent directory for repositories [$HOME/src]: " parent_dir
    DEFAULT_PARENT="${parent_dir:-$HOME/src}"
    
    echo
    echo -e "${YELLOW}3. Additional Settings${NC}"
    read -p "Enable VS Code integration? (y/n) [y]: " vscode
    ENABLE_VSCODE="${vscode:-y}"
    
    read -p "Create CLAUDE.md files for AI assistance? (y/n) [y]: " claude
    ENABLE_CLAUDE="${claude:-y}"
    
    read -p "Use repo-snippets for template files? (y/n) [y]: " snippets
    ENABLE_SNIPPETS="${snippets:-y}"
    
    if [[ "$ENABLE_SNIPPETS" == "y" ]]; then
        read -p "Local repo-snippets path [$HOME/src/repo-snippets]: " local_path
        SNIPPETS_LOCAL="${local_path:-$HOME/src/repo-snippets}"
        read -p "Remote repo-snippets URL [https://github.com/PowerAppsDarren/repo-snippets.git]: " remote_url
        SNIPPETS_REMOTE="${remote_url:-https://github.com/PowerAppsDarren/repo-snippets.git}"
    fi
    
    # Create config
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" << EOF
# Git-Go Configuration
# Generated by setup wizard on $(date)

# Primary git server
GIT_PRIMARY_HOST="$PRIMARY_HOST"
GIT_PRIMARY_USER="$PRIMARY_USER"
GIT_PRIMARY_PREFIX="$PRIMARY_PREFIX"

# Secondary git server
GIT_SECONDARY_HOST="$SECONDARY_HOST"
GIT_SECONDARY_USER="$SECONDARY_USER"
GIT_SECONDARY_PREFIX="$SECONDARY_PREFIX"

# Default branch name
DEFAULT_BRANCH="main"

# Default parent directory for repositories
DEFAULT_PARENT_DIR="$DEFAULT_PARENT"

# Features
ENABLE_VSCODE_INTEGRATION=$([ "$ENABLE_VSCODE" = "y" ] && echo "true" || echo "false")
ENABLE_CLAUDE_MD=$([ "$ENABLE_CLAUDE" = "y" ] && echo "true" || echo "false")

# Default templates
DEFAULT_GITIGNORE_TEMPLATES="node,python"

# Repo snippets
ENABLE_REPO_SNIPPETS=$([ "$ENABLE_SNIPPETS" = "y" ] && echo "true" || echo "false")
REPO_SNIPPETS_LOCAL="${SNIPPETS_LOCAL:-$HOME/src/repo-snippets}"
REPO_SNIPPETS_REMOTE="${SNIPPETS_REMOTE:-https://github.com/PowerAppsDarren/repo-snippets.git}"

# Colors
USE_COLORS=true
EOF
    
    success "Configuration saved to $CONFIG_FILE"
    echo
    echo "You can edit this file anytime with: git-go config"
}

# Show interactive menu
show_menu() {
    cat <<EOF
${BOLD}Git-Go v${VERSION}${NC} - Intelligent Git Repository Manager

What would you like to do?

  ${BOLD}1)${NC} Create a new repository
  ${BOLD}2)${NC} Fork an existing repository
  ${BOLD}3)${NC} Clone an existing repository
  ${BOLD}4)${NC} Edit configuration
  ${BOLD}5)${NC} Run setup wizard
  ${BOLD}6)${NC} Show version
  ${BOLD}7)${NC} Show help
  ${BOLD}8)${NC} Exit

EOF
    read -p "Enter your choice (1-8): " choice
    
    case $choice in
        1)
            COMMAND="new"
            ;;
        2)
            COMMAND="fork"
            ;;
        3)
            COMMAND="clone"
            ;;
        4)
            COMMAND="config"
            ;;
        5)
            COMMAND="setup"
            ;;
        6)
            COMMAND="version"
            ;;
        7)
            COMMAND="help"
            ;;
        8)
            echo "Goodbye!"
            exit 0
            ;;
        *)
            error "Invalid choice: $choice"
            exit 1
            ;;
    esac
}

# Main execution
main() {
    parse_args "$@"
    
    # If no command was provided, show interactive menu
    if [[ -z "$COMMAND" ]]; then
        # Check if config exists first
        if [[ ! -f "$CONFIG_FILE" ]]; then
            echo -e "${YELLOW}No configuration found. Running setup wizard...${NC}\n"
            setup_wizard
            echo
        fi
        load_config
        show_menu
    fi
    
    # Check if config exists (unless running setup/help/version)
    if [[ ! -f "$CONFIG_FILE" ]] && [[ ! "$COMMAND" =~ ^(setup|help|version|config)$ ]]; then
        echo -e "${YELLOW}No configuration found. Running setup wizard...${NC}\n"
        setup_wizard
        echo
    fi
    
    load_config
    
    # Ensure work directory exists
    mkdir -p "$WORK_DIR"
    
    case "$COMMAND" in
        new)
            cmd_new
            ;;
        fork)
            cmd_fork
            ;;
        clone)
            cmd_clone
            ;;
        config)
            cmd_config
            ;;
        status)
            cmd_status
            ;;
        setup)
            setup_wizard
            ;;
        version)
            cmd_version
            ;;
        help)
            usage
            ;;
        "")
            # Empty command is handled above by showing menu
            ;;
        *)
            error "Unknown command: $COMMAND"
            usage
            exit 1
            ;;
    esac
}

# Run main function
main "$@"