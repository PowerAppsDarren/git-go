#!/bin/bash
#
# Git-Go - Intelligent Git Repository Manager
# https://github.com/USERNAME/git-go
#
# Create and manage git repositories with smart sync scripts,
# VS Code integration, and AI-assisted development support.
#

set -e

# Script directory and paths
# Check if we're running from a symlink
SCRIPT_PATH="${BASH_SOURCE[0]}"
if [[ -L "$SCRIPT_PATH" ]]; then
    # Follow the symlink to get the real script location
    SCRIPT_PATH="$(readlink -f "$SCRIPT_PATH")"
fi
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")/.." && pwd)"
LIB_DIR="$SCRIPT_DIR/lib"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/git-go"
CONFIG_FILE="$CONFIG_DIR/config"

# Version
VERSION="1.0.7"

# Load libraries
source "$LIB_DIR/colors.sh"
source "$LIB_DIR/git-utils.sh"

# Load configuration
load_config() {
    # Default configuration
    GIT_PRIMARY_HOST="github.com"
    GIT_PRIMARY_USER="${USER}"
    GIT_PRIMARY_PREFIX="git@github.com:"
    GIT_SECONDARY_HOST=""
    GIT_SECONDARY_USER=""
    GIT_SECONDARY_PREFIX=""
    DEFAULT_BRANCH="main"
    ENABLE_VSCODE_INTEGRATION=true
    ENABLE_CLAUDE_MD=true
    DEFAULT_GITIGNORE_TEMPLATES="node,python"
    USE_COLORS=true
    
    # Load user config if exists
    if [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"
    fi
    
    # Set working directory
    WORK_DIR="${WORK_DIR:-$HOME/src}"
}

# Show usage
usage() {
    echo -e "${BOLD}Git-Go v${VERSION}${NC} - Intelligent Git Repository Manager

${BOLD}USAGE:${NC}
    git-go [OPTIONS] [COMMAND]

${BOLD}COMMANDS:${NC}
    new              Create a new repository
    fork             Fork an existing repository
    config           Edit configuration
    setup            Run setup wizard
    version          Show version information
    help             Show this help message

${BOLD}OPTIONS:${NC}
    -n, --name       Repository name (for new/fork)
    -u, --url        Repository URL (for fork)
    -d, --dir        Working directory (default: ~/src)
    --dry-run        Validate inputs without creating anything
    -h, --help       Show help message

${BOLD}EXAMPLES:${NC}
    git-go new --name my-project
    git-go fork --url https://github.com/user/repo
    git-go config"
}

# Parse command line arguments
parse_args() {
    COMMAND=""
    REPO_NAME=""
    REPO_URL=""
    DRY_RUN=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            new|fork|config|setup|version|help)
                COMMAND=$1
                shift
                ;;
            -n|--name)
                REPO_NAME="$2"
                shift 2
                ;;
            -u|--url)
                REPO_URL="$2"
                shift 2
                ;;
            -d|--dir)
                WORK_DIR="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
    
    # Default to help if no command
    COMMAND=${COMMAND:-help}
}

# Create VS Code integration
create_vscode_integration() {
    local repo_dir=$1
    
    if [[ "$ENABLE_VSCODE_INTEGRATION" != "true" ]]; then
        return
    fi
    
    mkdir -p "$repo_dir/.vscode"
    
    cat > "$repo_dir/.vscode/tasks.json" << 'EOF'
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Git Sync",
            "type": "shell",
            "command": "${workspaceFolder}/scripts/sync.sh",
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "presentation": {
                "reveal": "always",
                "panel": "terminal"
            },
            "problemMatcher": []
        }
    ]
}
EOF
}

# Create claude.md file
create_claude_md() {
    local repo_dir=$1
    local repo_name=$2
    
    if [[ "$ENABLE_CLAUDE_MD" != "true" ]]; then
        return
    fi
    
    cat > "$repo_dir/CLAUDE.md" << EOF
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project: $repo_name

### Quick Start
- Build: \`npm run build\` (update as needed)
- Test: \`npm test\` (update as needed)
- Lint: \`npm run lint\` (update as needed)

### Architecture Notes
<!-- Describe key architectural decisions and patterns -->

### Development Workflow
1. Make changes
2. Run tests
3. Use \`./scripts/sync.sh\` or Ctrl+Shift+B in VS Code to sync

### AI Assistant Guidelines
- Read relevant files before making changes
- Follow existing code patterns
- Consider impact on other components
- Suggest tests for new features
EOF
}

# Create sync script
create_sync_script() {
    local repo_dir=$1
    local repo_name=$2
    local is_fork=$3
    
    mkdir -p "$repo_dir/scripts"
    
    cat > "$repo_dir/scripts/sync.sh" << 'EOF'
#!/bin/bash
# Git sync script - generated by git-go

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Show repository status
echo -e "${BLUE}=== Git Sync ===${NC}"
echo -e "Repository: $(basename $(git rev-parse --show-toplevel))"
echo -e "Branch: $(git branch --show-current)"
echo -e "Status: $(git status --porcelain | wc -l) uncommitted changes"

# Check for uncommitted changes
if ! git diff-index --quiet HEAD -- 2>/dev/null; then
    echo -e "\n${YELLOW}You have uncommitted changes.${NC}"
    read -p "Stash them? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        git stash push -m "Auto-stash $(date +%Y%m%d-%H%M%S)"
        STASHED=true
    else
        echo -e "${RED}Cannot sync with uncommitted changes${NC}"
        exit 1
    fi
fi

# Get current branch
BRANCH=$(git branch --show-current)

EOF
    
    if [[ "$is_fork" == "true" ]]; then
        cat >> "$repo_dir/scripts/sync.sh" << 'EOF'
# Sync with upstream (for forks)
if git remote | grep -q upstream; then
    echo -e "\n${YELLOW}Fetching upstream...${NC}"
    git fetch upstream
    
    if git rev-list --count HEAD..upstream/$BRANCH &>/dev/null; then
        BEHIND=$(git rev-list --count HEAD..upstream/$BRANCH)
        if [[ $BEHIND -gt 0 ]]; then
            echo -e "${YELLOW}$BEHIND commits behind upstream${NC}"
            read -p "Merge upstream changes? (y/n) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                git merge upstream/$BRANCH -m "Merge upstream"
            fi
        fi
    fi
fi

EOF
    fi
    
    cat >> "$repo_dir/scripts/sync.sh" << 'EOF'
# Push to all remotes
for remote in $(git remote); do
    echo -e "\n${YELLOW}Pushing to $remote...${NC}"
    if git push $remote $BRANCH; then
        echo -e "${GREEN}✓ Pushed to $remote${NC}"
    else
        echo -e "${RED}✗ Failed to push to $remote${NC}"
    fi
done

# Restore stash if needed
if [[ "${STASHED:-false}" == "true" ]]; then
    echo
    read -p "Restore stashed changes? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        git stash pop
    fi
fi

echo -e "\n${GREEN}✅ Sync complete!${NC}"
EOF
    
    chmod +x "$repo_dir/scripts/sync.sh"
}

# Create a new repository
cmd_new() {
    local repo_name="$REPO_NAME"
    
    # Interactive mode if name not provided
    if [[ -z "$repo_name" ]]; then
        # In dry-run mode, we need a name
        if [[ "$DRY_RUN" == "true" ]]; then
            error "New command requires --name parameter"
            exit 1
        fi
        echo -e "${BOLD}Create New Repository${NC}\n"
        read -p "Repository name: " repo_name
    fi
    
    # Validate name
    if ! validate_repo_name "$repo_name"; then
        error "Invalid repository name. Use only letters, numbers, dots, hyphens, and underscores."
        exit 1
    fi
    
    # If dry-run, just validate and exit
    if [[ "$DRY_RUN" == "true" ]]; then
        success "Validation passed for repository name: $repo_name"
        exit 0
    fi
    
    local repo_dir="$WORK_DIR/$repo_name"
    
    # Check if already exists
    if [[ -d "$repo_dir" ]]; then
        error "Directory $repo_dir already exists!"
        exit 1
    fi
    
    # Create repository
    step "Creating repository at $repo_dir"
    mkdir -p "$repo_dir"
    cd "$repo_dir"
    
    git init -b "$DEFAULT_BRANCH"
    
    # Create initial files
    step "Creating initial files"
    
    echo "# $repo_name" > README.md
    echo "" >> README.md
    echo "## Description" >> README.md
    echo "" >> README.md
    echo "Add your project description here." >> README.md
    
    # Create .gitignore
    touch .gitignore
    
    # Add common patterns
    cat >> .gitignore << 'EOF'
# OS
.DS_Store
Thumbs.db

# Editor
.vscode/*
!.vscode/tasks.json
.idea/
*.swp
*.swo

# Logs
*.log
logs/

# Environment
.env
.env.*
!.env.example
EOF
    
    # Add template-specific patterns
    if [[ -n "$DEFAULT_GITIGNORE_TEMPLATES" ]]; then
        IFS=',' read -ra TEMPLATES <<< "$DEFAULT_GITIGNORE_TEMPLATES"
        for template in "${TEMPLATES[@]}"; do
            case "$template" in
                node)
                    echo -e "\n# Node\nnode_modules/\ndist/\n.npm/" >> .gitignore
                    ;;
                python)
                    echo -e "\n# Python\n__pycache__/\n*.pyc\nvenv/\n.pytest_cache/" >> .gitignore
                    ;;
                go)
                    echo -e "\n# Go\n*.exe\n*.test\n*.out\nvendor/" >> .gitignore
                    ;;
            esac
        done
    fi
    
    # Create LICENSE
    cat > LICENSE << EOF
MIT License

Copyright (c) $(date +%Y) $GIT_PRIMARY_USER

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
EOF
    
    # Create VS Code integration
    create_vscode_integration "$repo_dir"
    
    # Create claude.md
    create_claude_md "$repo_dir" "$repo_name"
    
    # Create sync script
    create_sync_script "$repo_dir" "$repo_name" "false"
    
    # Initial commit
    git add .
    git commit -m "Initial commit"
    
    # Setup remotes
    step "Setting up remotes"
    
    if [[ -n "$GIT_PRIMARY_PREFIX" ]]; then
        local primary_url="${GIT_PRIMARY_PREFIX}${GIT_PRIMARY_USER}/${repo_name}.git"
        setup_remote "origin" "$primary_url"
        info "Primary remote: $primary_url"
    fi
    
    if [[ -n "$GIT_SECONDARY_PREFIX" ]]; then
        local secondary_url="${GIT_SECONDARY_PREFIX}${GIT_SECONDARY_USER}/${repo_name}.git"
        setup_remote "secondary" "$secondary_url"
        info "Secondary remote: $secondary_url"
    fi
    
    # Try to push
    if [[ -n "$GIT_PRIMARY_PREFIX" ]]; then
        step "Pushing to remotes"
        if git push -u origin "$DEFAULT_BRANCH" 2>&1; then
            success "Pushed to origin"
        else
            warning "Push to origin failed (this is normal if auto-create is disabled on your git server)"
        fi
    fi
    
    success "Repository created successfully!"
    echo
    highlight "Next steps:"
    echo "  cd $repo_dir"
    echo "  # Start coding!"
    echo "  ./scripts/sync.sh  # or Ctrl+Shift+B in VS Code"
}

# Fork a repository
cmd_fork() {
    local repo_url="$REPO_URL"
    
    # Interactive mode if URL not provided
    if [[ -z "$repo_url" ]]; then
        # In dry-run mode, we need a URL
        if [[ "$DRY_RUN" == "true" ]]; then
            error "Fork command requires --url parameter"
            exit 1
        fi
        echo -e "${BOLD}Fork Repository${NC}\n"
        read -p "Repository URL: " repo_url
    fi
    
    # Extract repo info
    local repo_info=$(extract_repo_info "$repo_url")
    local author=$(echo "$repo_info" | cut -d'|' -f1)
    local repo=$(echo "$repo_info" | cut -d'|' -f2)
    
    if [[ -z "$author" ]] || [[ -z "$repo" ]]; then
        error "Could not parse repository URL"
        exit 1
    fi
    
    # If dry-run, just validate and exit
    if [[ "$DRY_RUN" == "true" ]]; then
        success "Validation passed for fork URL: $repo_url"
        exit 0
    fi
    
    local repo_name="${REPO_NAME:-$repo}"
    local repo_dir="$WORK_DIR/$repo_name"
    
    # Check if already exists
    if [[ -d "$repo_dir" ]]; then
        error "Directory $repo_dir already exists!"
        exit 1
    fi
    
    # Clone repository
    step "Cloning $repo_url"
    git clone "$repo_url" "$repo_dir"
    cd "$repo_dir"
    
    # Get default branch
    local default_branch=$(get_default_branch origin)
    
    # Setup remotes
    step "Setting up remotes"
    git remote rename origin upstream
    
    if [[ -n "$GIT_PRIMARY_PREFIX" ]]; then
        local primary_url="${GIT_PRIMARY_PREFIX}${GIT_PRIMARY_USER}/${repo_name}.git"
        setup_remote "origin" "$primary_url"
        info "Primary remote: $primary_url"
    fi
    
    if [[ -n "$GIT_SECONDARY_PREFIX" ]]; then
        local secondary_url="${GIT_SECONDARY_PREFIX}${GIT_SECONDARY_USER}/${repo_name}.git"
        setup_remote "secondary" "$secondary_url"
        info "Secondary remote: $secondary_url"
    fi
    
    # Create VS Code integration
    create_vscode_integration "$repo_dir"
    
    # Create claude.md
    create_claude_md "$repo_dir" "$repo_name"
    
    # Create sync script
    create_sync_script "$repo_dir" "$repo_name" "true"
    
    # Try to push
    if [[ -n "$GIT_PRIMARY_PREFIX" ]]; then
        step "Pushing to your remotes"
        if git push -u origin "$default_branch" 2>/dev/null; then
            success "Pushed to origin"
        else
            warning "Could not push to origin. Create the repository first."
        fi
    fi
    
    success "Fork created successfully!"
    echo
    highlight "Next steps:"
    echo "  cd $repo_dir"
    echo "  # Make your changes"
    echo "  ./scripts/sync.sh  # Sync with upstream and your remotes"
}

# Edit configuration
cmd_config() {
    # Create config directory if needed
    mkdir -p "$CONFIG_DIR"
    
    # Copy example if no config exists
    if [[ ! -f "$CONFIG_FILE" ]]; then
        cp "$SCRIPT_DIR/config/git-go.conf.example" "$CONFIG_FILE"
        info "Created configuration file at $CONFIG_FILE"
    fi
    
    # Open in editor
    if [[ -n "$EDITOR" ]]; then
        $EDITOR "$CONFIG_FILE"
    elif command_exists code; then
        code "$CONFIG_FILE"
    elif command_exists nano; then
        nano "$CONFIG_FILE"
    else
        vi "$CONFIG_FILE"
    fi
}

# Show version
cmd_version() {
    echo "Git-Go v${VERSION}"
}

# Setup wizard for first-time configuration
setup_wizard() {
    echo -e "${BOLD}Git-Go Setup Wizard${NC}\n"
    echo "Let's configure Git-Go for your environment."
    echo
    
    # Primary git service
    echo -e "${YELLOW}1. Primary Git Service${NC}"
    echo "Choose your primary git hosting service:"
    echo "  1) GitHub"
    echo "  2) GitLab"
    echo "  3) Bitbucket"
    echo "  4) Self-hosted"
    echo "  5) Other"
    read -p "Choice (1-5): " choice
    
    case $choice in
        1)
            PRIMARY_PREFIX="git@github.com:"
            PRIMARY_HOST="github.com"
            ;;
        2)
            PRIMARY_PREFIX="git@gitlab.com:"
            PRIMARY_HOST="gitlab.com"
            ;;
        3)
            PRIMARY_PREFIX="git@bitbucket.org:"
            PRIMARY_HOST="bitbucket.org"
            ;;
        4|5)
            read -p "Git server hostname: " PRIMARY_HOST
            read -p "Git URL prefix (e.g., git@example.com: or ssh://git@example.com/): " PRIMARY_PREFIX
            ;;
        *)
            PRIMARY_PREFIX="git@github.com:"
            PRIMARY_HOST="github.com"
            ;;
    esac
    
    # Username
    echo
    read -p "Your username on $PRIMARY_HOST [$USER]: " git_user
    PRIMARY_USER="${git_user:-$USER}"
    
    # Secondary remote
    echo
    read -p "Configure a secondary remote? (y/n) [n]: " setup_secondary
    if [[ "$setup_secondary" =~ ^[Yy]$ ]]; then
        echo
        read -p "Secondary git server hostname: " SECONDARY_HOST
        read -p "Secondary git URL prefix: " SECONDARY_PREFIX
        read -p "Your username on $SECONDARY_HOST [$PRIMARY_USER]: " sec_user
        SECONDARY_USER="${sec_user:-$PRIMARY_USER}"
    else
        SECONDARY_HOST=""
        SECONDARY_PREFIX=""
        SECONDARY_USER=""
    fi
    
    # Other settings
    echo
    echo -e "${YELLOW}2. Additional Settings${NC}"
    read -p "Enable VS Code integration? (y/n) [y]: " vscode
    ENABLE_VSCODE="${vscode:-y}"
    
    read -p "Create CLAUDE.md files for AI assistance? (y/n) [y]: " claude
    ENABLE_CLAUDE="${claude:-y}"
    
    # Create config
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" << EOF
# Git-Go Configuration
# Generated by setup wizard on $(date)

# Primary git server
GIT_PRIMARY_HOST="$PRIMARY_HOST"
GIT_PRIMARY_USER="$PRIMARY_USER"
GIT_PRIMARY_PREFIX="$PRIMARY_PREFIX"

# Secondary git server
GIT_SECONDARY_HOST="$SECONDARY_HOST"
GIT_SECONDARY_USER="$SECONDARY_USER"
GIT_SECONDARY_PREFIX="$SECONDARY_PREFIX"

# Default branch name
DEFAULT_BRANCH="main"

# Features
ENABLE_VSCODE_INTEGRATION=$([ "$ENABLE_VSCODE" = "y" ] && echo "true" || echo "false")
ENABLE_CLAUDE_MD=$([ "$ENABLE_CLAUDE" = "y" ] && echo "true" || echo "false")

# Default templates
DEFAULT_GITIGNORE_TEMPLATES="node,python"

# Colors
USE_COLORS=true
EOF
    
    success "Configuration saved to $CONFIG_FILE"
    echo
    echo "You can edit this file anytime with: git-go config"
}

# Main execution
main() {
    parse_args "$@"
    
    # Check if config exists (unless running setup/help/version)
    if [[ ! -f "$CONFIG_FILE" ]] && [[ ! "$COMMAND" =~ ^(setup|help|version|config)$ ]]; then
        echo -e "${YELLOW}No configuration found. Running setup wizard...${NC}\n"
        setup_wizard
        echo
    fi
    
    load_config
    
    # Ensure work directory exists
    mkdir -p "$WORK_DIR"
    
    case "$COMMAND" in
        new)
            cmd_new
            ;;
        fork)
            cmd_fork
            ;;
        config)
            cmd_config
            ;;
        setup)
            setup_wizard
            ;;
        version)
            cmd_version
            ;;
        help)
            usage
            ;;
        *)
            error "Unknown command: $COMMAND"
            usage
            exit 1
            ;;
    esac
}

# Run main function
main "$@"